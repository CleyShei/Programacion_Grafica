<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Visualizador 3D </title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
      overflow: hidden;
    }
    
    #container {
      display: flex;
      height: 100vh;
    }
    
    #canvas-container {
      flex: 1;
      position: relative;
    }
    
    #webglcanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    #controls {
      width: 300px;
      background-color: #2c3e50;
      color: white;
      padding: 15px;
      overflow-y: auto;
      box-shadow: -2px 0 5px rgba(0,0,0,0.2);
    }
    
    .control-group {
      margin-bottom: 20px;
      border-bottom: 1px solid #34495e;
      padding-bottom: 15px;
    }
    
    .control-group h3 {
      margin-top: 0;
      color: #3498db;
      font-size: 16px;
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .control-label {
      width: 120px;
      font-size: 14px;
    }
    
    .control-input {
      flex: 1;
    }
    
    input[type="range"] {
      width: 100%;
    }
    
    input[type="color"] {
      width: 100%;
      height: 30px;
      border: none;
      border-radius: 3px;
    }
    
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 3px;
      cursor: pointer;
      width: 100%;
      margin-top: 5px;
    }
    
    button:hover {
      background-color: #2980b9;
    }
    
    select {
      width: 100%;
      padding: 5px;
      border-radius: 3px;
      border: 1px solid #34495e;
      background-color: #34495e;
      color: white;
    }
    
    .checkbox-container {
      display: flex;
      align-items: center;
    }
    
    .checkbox-container input {
      margin-right: 8px;
    }
    
    .info-text {
      font-size: 12px;
      color: #bdc3c7;
      margin-top: 5px;
    }
    
    #status {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="canvas-container">
      <canvas id="webglcanvas"></canvas>
      <div id="status">Cargando modelos...</div>
    </div>
    <div id="controls">
      <div class="control-group">
        <h3>Vista y Navegación</h3>
        <div class="control-row">
          <div class="control-label">Tipo de Vista:</div>
          <div class="control-input">
            <select id="vista">
              <option value="perspectiva">Perspectiva</option>
              <option value="ortogonal">Ortogonal</option>
            </select>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Zoom:</div>
          <div class="control-input">
            <input type="range" id="zoom" min="1" max="20" value="8" step="0.1">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotar Vista X:</div>
          <div class="control-input">
            <input type="range" id="rotarVistaX" min="-180" max="180" value="0">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotar Vista Y:</div>
          <div class="control-input">
            <input type="range" id="rotarVistaY" min="-180" max="180" value="0">
          </div>
        </div>
        <div class="info-text">Usa las flechas para mover la vista</div>
      </div>
      
      <div class="control-group">
        <h3>Objeto Seleccionado</h3>
        <div class="control-row">
          <div class="control-label">Objeto:</div>
          <div class="control-input">
            <select id="objetoSeleccionado">
              <option value="todos">Todos los Objetos</option>
              <option value="auto">Auto</option>
              <option value="gato">Gato</option>
              <option value="pinguino">Pingüino</option>
            </select>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Posición X:</div>
          <div class="control-input">
            <input type="range" id="posX" min="-3" max="3" value="0" step="0.1">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Posición Y:</div>
          <div class="control-input">
            <input type="range" id="posY" min="-3" max="3" value="0" step="0.1">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación Y:</div>
          <div class="control-input">
            <input type="range" id="rotX" min="0" max="360" value="0">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación Z:</div>
          <div class="control-input">
            <input type="range" id="rotY" min="0" max="360" value="0">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación X:</div>
          <div class="control-input">
            <input type="range" id="rotZ" min="0" max="360" value="0">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Escala:</div>
          <div class="control-input">
            <input type="range" id="escala" min="0.1" max="3" value="1" step="0.1">
          </div>
        </div>
        <button id="resetObjeto">Reiniciar Objeto</button>
      </div>
      
      <div class="control-group">
        <h3>Apariencia</h3>
        <div class="control-row">
          <div class="control-label">Color Auto:</div>
          <div class="control-input">
            <input type="color" id="colorAuto" value="#ff0000">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Color Gato:</div>
          <div class="control-input">
            <input type="color" id="colorGato" value="#ff8800">
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Color Pingüino:</div>
          <div class="control-input">
            <input type="color" id="colorPinguino" value="#1a1a1a">
          </div>
        </div>
        <div class="control-row">
          <div class="checkbox-container">
            <input type="checkbox" id="animacion">
            <label for="animacion">Animación Automática</label>
          </div>
        </div>
        <div class="control-row">
          <div class="checkbox-container">
            <input type="checkbox" id="mostrarEjes" checked>
            <label for="mostrarEjes">Mostrar Ejes</label>
          </div>
        </div>
        <div class="control-row">
          <div class="checkbox-container">
            <input type="checkbox" id="usarColoresOriginales" checked>
            <label for="usarColoresOriginales">Usar Colores Originales</label>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Controles Rápidos</h3>
        <button id="vistaFrontal">Vista Frontal</button>
        <button id="vistaLateral">Vista Lateral</button>
        <button id="vistaSuperior">Vista Superior</button>
        <button id="resetTodo">Reiniciar Todo</button>
      </div>
    </div>
  </div>

  <script id="vs" type="vertex">
    #version 300 es
    precision mediump float;
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;        
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    void main() {
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    uniform vec4 uColor;
    out vec4 color;
    void main() {
        color = uColor;
    }
  </script>

  <script>
    "use strict";

    // Variables globales
    let programaID;
    let gl;
    let objetoAuto, objetoGato, objetoPinguino;
    let ejes;

    // Variables Uniformes
    let uColor;
    let uMatrizProyeccion;
    let uMatrizVista;
    let uMatrizModelo;

    // Matrices
    let MatrizProyeccion = new Array(16);
    let MatrizVista = new Array(16);
    let MatrizModelo = new Array(16);

    // Matrices de modelo para cada objeto
    let MatrizModeloAuto = new Array(16);
    let MatrizModeloGato = new Array(16);
    let MatrizModeloPinguino = new Array(16);

    // Variables de control
    let rotacionAuto = { x: 0, y: 0, z: 0 };
    let rotacionGato = { x: 0, y: 0, z: 0 };
    let rotacionPinguino = { x: 0, y: 0, z: 0 };
    
    let posicionAuto = { x: -2, y: 0, z: 0 };
    let posicionGato = { x: 0, y: 0, z: 0 };
    let posicionPinguino = { x: 2, y: 0, z: 0 };
    
    let escalaAuto = 1.0;
    let escalaGato = 1.0;
    let escalaPinguino = 1.0;
    
    let colorAuto = [1.0, 0.0, 0.0]; // Rojo
    let colorGato = [1.0, 0.53, 0.0]; // Naranja
    let colorPinguino = [0.1, 0.1, 0.1]; // Negro jaspeado

    // Variables de cámara/vista
    let rotacionVistaX = 0;
    let rotacionVistaY = 0;
    let zoom = 8;
    let tipoVista = "perspectiva";

    // Animación
    let animacionActiva = false;
    const INC_ROTACION = 0.5;

    // Estado
    let objetoSeleccionado = "todos";
    let usarColoresOriginales = true;

    // Elementos de UI
    let controles = {};

    /***************************************************************************/
    /* Inicialización y configuración                                          */
    /***************************************************************************/
    function inicializarControles() {
      // Obtener referencias a todos los controles
      controles.vista = document.getElementById("vista");
      controles.zoom = document.getElementById("zoom");
      controles.rotarVistaX = document.getElementById("rotarVistaX");
      controles.rotarVistaY = document.getElementById("rotarVistaY");
      controles.objetoSeleccionado = document.getElementById("objetoSeleccionado");
      controles.posX = document.getElementById("posX");
      controles.posY = document.getElementById("posY");
      controles.rotX = document.getElementById("rotX");
      controles.rotY = document.getElementById("rotY");
      controles.rotZ = document.getElementById("rotZ");
      controles.escala = document.getElementById("escala");
      controles.colorAuto = document.getElementById("colorAuto");
      controles.colorGato = document.getElementById("colorGato");
      controles.colorPinguino = document.getElementById("colorPinguino");
      controles.animacion = document.getElementById("animacion");
      controles.mostrarEjes = document.getElementById("mostrarEjes");
      controles.usarColoresOriginales = document.getElementById("usarColoresOriginales");
      controles.resetObjeto = document.getElementById("resetObjeto");
      controles.vistaFrontal = document.getElementById("vistaFrontal");
      controles.vistaLateral = document.getElementById("vistaLateral");
      controles.vistaSuperior = document.getElementById("vistaSuperior");
      controles.resetTodo = document.getElementById("resetTodo");
      
      // Configurar eventos
      controles.vista.addEventListener("change", actualizarVista);
      controles.zoom.addEventListener("input", actualizarZoom);
      controles.rotarVistaX.addEventListener("input", actualizarRotacionVista);
      controles.rotarVistaY.addEventListener("input", actualizarRotacionVista);
      controles.objetoSeleccionado.addEventListener("change", cambiarObjetoSeleccionado);
      controles.posX.addEventListener("input", actualizarPosicion);
      controles.posY.addEventListener("input", actualizarPosicion);
      controles.rotX.addEventListener("input", actualizarRotacion);
      controles.rotY.addEventListener("input", actualizarRotacion);
      controles.rotZ.addEventListener("input", actualizarRotacion);
      controles.escala.addEventListener("input", actualizarEscala);
      controles.colorAuto.addEventListener("input", actualizarColor);
      controles.colorGato.addEventListener("input", actualizarColor);
      controles.colorPinguino.addEventListener("input", actualizarColor);
      controles.animacion.addEventListener("change", toggleAnimacion);
      controles.mostrarEjes.addEventListener("change", dibujar);
      controles.usarColoresOriginales.addEventListener("change", toggleColoresOriginales);
      controles.resetObjeto.addEventListener("click", resetObjeto);
      controles.vistaFrontal.addEventListener("click", () => cambiarVista('frontal'));
      controles.vistaLateral.addEventListener("click", () => cambiarVista('lateral'));
      controles.vistaSuperior.addEventListener("click", () => cambiarVista('superior'));
      controles.resetTodo.addEventListener("click", resetTodo);
      
      // Configurar eventos de teclado para navegación
      document.addEventListener("keydown", manejarTeclado);
      
      // Actualizar controles con valores iniciales
      actualizarControlesDesdeEstado();
    }

    function actualizarControlesDesdeEstado() {
      controles.zoom.value = zoom;
      controles.rotarVistaX.value = rotacionVistaX;
      controles.rotarVistaY.value = rotacionVistaY;
      controles.vista.value = tipoVista;
      
      // Actualizar controles según el objeto seleccionado
      actualizarControlesObjeto();
    }

    function actualizarControlesObjeto() {
      let posX, posY, rotX, rotY, rotZ, escala;
      
      switch(objetoSeleccionado) {
        case "auto":
          posX = posicionAuto.x;
          posY = posicionAuto.y;
          rotX = rotacionAuto.x;
          rotY = rotacionAuto.y;
          rotZ = rotacionAuto.z;
          escala = escalaAuto;
          break;
        case "gato":
          posX = posicionGato.x;
          posY = posicionGato.y;
          rotX = rotacionGato.x;
          rotY = rotacionGato.y;
          rotZ = rotacionGato.z;
          escala = escalaGato;
          break;
        case "pinguino":
          posX = posicionPinguino.x;
          posY = posicionPinguino.y;
          rotX = rotacionPinguino.x;
          rotY = rotacionPinguino.y;
          rotZ = rotacionPinguino.z;
          escala = escalaPinguino;
          break;
        default: // todos
          // Para "todos", mostramos valores promediados o dejamos en cero
          posX = 0;
          posY = 0;
          rotX = 0;
          rotY = 0;
          rotZ = 0;
          escala = 1;
      }
      
      controles.posX.value = posX;
      controles.posY.value = posY;
      controles.rotX.value = rotX;
      controles.rotY.value = rotY;
      controles.rotZ.value = rotZ;
      controles.escala.value = escala;
    }

    /***************************************************************************/
    /* Manejo de eventos de UI                                                 */
    /***************************************************************************/
    function actualizarVista() {
      tipoVista = controles.vista.value;
      configurarProyeccion();
      dibujar();
    }

    function actualizarZoom() {
      zoom = parseFloat(controles.zoom.value);
      configurarProyeccion();
      dibujar();
    }

    function actualizarRotacionVista() {
      rotacionVistaX = parseFloat(controles.rotarVistaX.value);
      rotacionVistaY = parseFloat(controles.rotarVistaY.value);
      configurarVista();
      dibujar();
    }

    function cambiarObjetoSeleccionado() {
      objetoSeleccionado = controles.objetoSeleccionado.value;
      actualizarControlesObjeto();
    }

    function actualizarPosicion() {
      const x = parseFloat(controles.posX.value);
      const y = parseFloat(controles.posY.value);
      
      switch(objetoSeleccionado) {
        case "auto":
          posicionAuto.x = x;
          posicionAuto.y = y;
          break;
        case "gato":
          posicionGato.x = x;
          posicionGato.y = y;
          break;
        case "pinguino":
          posicionPinguino.x = x;
          posicionPinguino.y = y;
          break;
        case "todos":
          posicionAuto.x = x;
          posicionAuto.y = y;
          posicionGato.x = x;
          posicionGato.y = y;
          posicionPinguino.x = x;
          posicionPinguino.y = y;
          break;
      }
      
      dibujar();
    }

    function actualizarRotacion() {
      const x = parseFloat(controles.rotX.value);
      const y = parseFloat(controles.rotY.value);
      const z = parseFloat(controles.rotZ.value);
      
      switch(objetoSeleccionado) {
        case "auto":
          rotacionAuto.x = x;
          rotacionAuto.y = y;
          rotacionAuto.z = z;
          break;
        case "gato":
          rotacionGato.x = x;
          rotacionGato.y = y;
          rotacionGato.z = z;
          break;
        case "pinguino":
          rotacionPinguino.x = x;
          rotacionPinguino.y = y;
          rotacionPinguino.z = z;
          break;
        case "todos":
          rotacionAuto.x = x;
          rotacionAuto.y = y;
          rotacionAuto.z = z;
          rotacionGato.x = x;
          rotacionGato.y = y;
          rotacionGato.z = z;
          rotacionPinguino.x = x;
          rotacionPinguino.y = y;
          rotacionPinguino.z = z;
          break;
      }
      
      dibujar();
    }

    function actualizarEscala() {
      const escala = parseFloat(controles.escala.value);
      
      switch(objetoSeleccionado) {
        case "auto":
          escalaAuto = escala;
          break;
        case "gato":
          escalaGato = escala;
          break;
        case "pinguino":
          escalaPinguino = escala;
          break;
        case "todos":
          escalaAuto = escala;
          escalaGato = escala;
          escalaPinguino = escala;
          break;
      }
      
      dibujar();
    }

    function actualizarColor() {
      // Convertir color hex a RGB
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [0, 0, 0];
      }
      
      colorAuto = hexToRgb(controles.colorAuto.value);
      colorGato = hexToRgb(controles.colorGato.value);
      colorPinguino = hexToRgb(controles.colorPinguino.value);
      
      dibujar();
    }

    function toggleAnimacion() {
      animacionActiva = controles.animacion.checked;
    }

    function toggleColoresOriginales() {
      usarColoresOriginales = controles.usarColoresOriginales.checked;
      dibujar();
    }

    function resetObjeto() {
      switch(objetoSeleccionado) {
        case "auto":
          rotacionAuto = { x: 0, y: 0, z: 0 };
          posicionAuto = { x: -2, y: 0, z: 0 };
          escalaAuto = 1.0;
          break;
        case "gato":
          rotacionGato = { x: 0, y: 0, z: 0 };
          posicionGato = { x: 0, y: 0, z: 0 };
          escalaGato = 1.0;
          break;
        case "pinguino":
          rotacionPinguino = { x: 0, y: 0, z: 0 };
          posicionPinguino = { x: 2, y: 0, z: 0 };
          escalaPinguino = 1.0;
          break;
        case "todos":
          rotacionAuto = { x: 0, y: 0, z: 0 };
          posicionAuto = { x: -2, y: 0, z: 0 };
          escalaAuto = 1.0;
          rotacionGato = { x: 0, y: 0, z: 0 };
          posicionGato = { x: 0, y: 0, z: 0 };
          escalaGato = 1.0;
          rotacionPinguino = { x: 0, y: 0, z: 0 };
          posicionPinguino = { x: 2, y: 0, z: 0 };
          escalaPinguino = 1.0;
          break;
      }
      
      actualizarControlesObjeto();
      dibujar();
    }

    function cambiarVista(tipo) {
      switch(tipo) {
        case 'frontal':
          rotacionVistaX = 0;
          rotacionVistaY = 0;
          break;
        case 'lateral':
          rotacionVistaX = 0;
          rotacionVistaY = 90;
          break;
        case 'superior':
          rotacionVistaX = 90;
          rotacionVistaY = 0;
          break;
      }
      
      controles.rotarVistaX.value = rotacionVistaX;
      controles.rotarVistaY.value = rotacionVistaY;
      configurarVista();
      dibujar();
    }

    function resetTodo() {
      // Resetear vista
      zoom = 8;
      rotacionVistaX = 0;
      rotacionVistaY = 0;
      tipoVista = "perspectiva";
      
      // Resetear objetos
      rotacionAuto = { x: 0, y: 0, z: 0 };
      posicionAuto = { x: -2, y: 0, z: 0 };
      escalaAuto = 1.0;
      
      rotacionGato = { x: 0, y: 0, z: 0 };
      posicionGato = { x: 0, y: 0, z: 0 };
      escalaGato = 1.0;
      
      rotacionPinguino = { x: 0, y: 0, z: 0 };
      posicionPinguino = { x: 2, y: 0, z: 0 };
      escalaPinguino = 1.0;
      
      // Resetear colores
      colorAuto = [1.0, 0.0, 0.0];
      colorGato = [1.0, 0.53, 0.0];
      colorPinguino = [0.1, 0.1, 0.1]; // Negro jaspeado
      
      // Actualizar controles
      actualizarControlesDesdeEstado();
      controles.colorAuto.value = "#ff0000";
      controles.colorGato.value = "#ff8800";
      controles.colorPinguino.value = "#1a1a1a"; // Negro jaspeado
      
      dibujar();
    }

    function manejarTeclado(event) {
      const step = 5; // Grados para rotación
      const zoomStep = 0.5; // Paso para zoom
      
      switch(event.key) {
        case "ArrowUp":
          rotacionVistaX = (rotacionVistaX - step) % 360;
          break;
        case "ArrowDown":
          rotacionVistaX = (rotacionVistaX + step) % 360;
          break;
        case "ArrowLeft":
          rotacionVistaY = (rotacionVistaY - step) % 360;
          break;
        case "ArrowRight":
          rotacionVistaY = (rotacionVistaY + step) % 360;
          break;
        case "PageUp":
          zoom = Math.min(20, zoom + zoomStep);
          break;
        case "PageDown":
          zoom = Math.max(1, zoom - zoomStep);
          break;
        default:
          return; // Salir si no es una tecla que nos interesa
      }
      
      // Actualizar controles
      controles.rotarVistaX.value = rotacionVistaX;
      controles.rotarVistaY.value = rotacionVistaY;
      controles.zoom.value = zoom;
      
      configurarProyeccion();
      configurarVista();
      dibujar();
      
      event.preventDefault();
    }

    /***************************************************************************/
    /* Funciones de transformación y matrices                                  */
    /***************************************************************************/
    function toRadians(grados) {
      return grados * Math.PI / 180;
    }

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function traslacion(matriz, tx, ty, tz) {
      let r = new Array(16);
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function escalacion(matriz, sx, sy, sz) { 
      let r = new Array(16);
      r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
      r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
      r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    function rotacionX(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
      r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
      r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r); 
    }

    function rotacionY(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
      r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
      r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionZ(matriz, theta){
      let r = new Array(16);
      let c = Math.cos(toRadians(theta));
      let s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
      r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
      r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der - izq); r[4] = 0; r[ 8] = 0; r[12] = -(der + izq)/(der - izq);
      r[1] = 0; r[5] = 2/(arr - abj); r[ 9] = 0; r[13] = -(arr + abj)/(arr - abj);
      r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function perspective(r, fovy, aspecto, cerca, lejos) {
      let ang = fovy * 0.5;
      let f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
      r[0] = f/aspecto; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = f; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] = -2.0 * lejos * cerca / (lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = -1.0; r[15] = 0;
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++){
        for (j = 0; j < 4; j++){
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    function configurarProyeccion() {
      const aspecto = gl.canvas.width / gl.canvas.height;
      
      if (tipoVista === "perspectiva") {
        perspective(MatrizProyeccion, 45, aspecto, 0.1, 100);
      } else {
        const dimension = zoom;
        ortho(MatrizProyeccion, -dimension * aspecto, dimension * aspecto, -dimension, dimension, -100, 100);
      }
      
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
    }

    function configurarVista() {
      identidad(MatrizVista);
      
      // CORRECCIÓN: Aplicar rotaciones en el orden correcto
      // Primero rotación Y (horizontal), luego rotación X (vertical)
      rotacionY(MatrizVista, rotacionVistaY);
      rotacionX(MatrizVista, rotacionVistaX);
      
      // Aplicar zoom (trasladar en Z)
      traslacion(MatrizVista, 0, 0, -zoom);
      
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
    }

    /***************************************************************************/
    /* Clases para manejar objetos 3D                                          */
    /***************************************************************************/
    class Grupo {
      constructor() {
        this.nombre = "si_falta";
        this.triangulos = new Array();
        this.material = 0;
      }
      setNombre(nombre) {
        this.nombre = nombre;
      }
      getNombre() {
        return this.nombre;
      }
      adiTriangulo(t) {
        this.triangulos.push(t);
      }
      getTriangulo(indice){
        return this.triangulos[indice];
      }
      getNumTriangulos(){
        return this.triangulos.length;
      }
      setMaterial(material){
        this.material = material;
      }
      getMaterial() {
        return this.material;
      }
    }

    class Material {
      constructor() {
        this.nombre    = "si_falta";
        this.ambiente  = [0.2,0.2,0.2];
        this.difuso    = [0.8,0.8,0.8];
        this.especular = [0.0,0.0,0.0];
        this.brillo    = 0;
      }
      setNombre(nombre) {
        this.nombre = nombre;
      }
      getNombre() {
        return this.nombre;
      }
      setAmbiente(ambiente) {
        this.ambiente = ambiente;
      }
      getAmbiente() {
        return this.ambiente;
      }
      setDifuso(difuso) {
        this.difuso = difuso;
      }
      getDifuso() {
        return this.difuso;
      }
      setEspecular(especular) {
        this.especular = especular;
      }
      getEspecular() {
        return this.especular;
      }
      setBrillo(brillo) {
        this.brillo = brillo;
      }
      getBrillo() {
        return this.brillo;
      }
    }

    class Cadena {
      constructor(cadena) {
        this.cadena = cadena;
        this.indice = 0;
      }
      esDelimitador(c) {
        return (
          c == ' ' ||
          c == '\t' ||
          c == '(' ||
          c == ')' ||
          c == '"' ||
          c == "'"
       );
      }
      saltaDelimitadores() {
        let n = this.cadena.length;
        while (this.indice < n && 
                 this.esDelimitador(this.cadena.charAt(this.indice))) {
          this.indice++;
        }
      };
      obtLongPalabra(inicio) {
        let i = inicio;
        while (i < this.cadena.length &&
                !this.esDelimitador(this.cadena.charAt(i))) {
             i++;
        }
        return i - inicio;
      };
      getToken() {
        let n, subcadena;
        this.saltaDelimitadores();
        n = this.obtLongPalabra(this.indice);
        if (n === 0) {
          return null;
        }
        subcadena = this.cadena.substr(this.indice, n);
        this.indice = this.indice + (n + 1);
        return subcadena.trim();
      }
      getInt() {
        let token = this.getToken();
        if (token) {
          return parseInt(token, 10);
        }
        return null;
      }
      getFloat() {
        let token = this.getToken();
        if (token) {
          return parseFloat(token);
        }
        return null;
      }
    }

    class Objeto {
      constructor(gl, nombreArchivo, colorPorDefecto) {
        this.vertices = [];
        this.indices = [];
        this.grupos = [];
        this.materiales = [];
        this.color = colorPorDefecto || [1.0, 1.0, 1.0];
        
        this.cargarObjeto(gl, nombreArchivo);
      }

      cargarObjeto(gl, nombreArchivo) {
        let lineas, token, x, y, z, a, b;
        let minX, maxX, minY, maxY, minZ, maxZ;
        let numVertices, numTriangulos, indiceDeGrupo;
        let hayGrupos;

        numVertices = 0;
        numTriangulos = 0;
        hayGrupos = false;

        let datos_obj = this.leeArchivo(nombreArchivo);
        lineas = datos_obj.split("\n");

        minX = Number.MAX_VALUE; maxX = Number.MIN_VALUE;
        minY = Number.MAX_VALUE; maxY = Number.MIN_VALUE;
        minZ = Number.MAX_VALUE; maxZ = Number.MIN_VALUE;

        for (let i = 0; i < lineas.length; i++) {
          let cad = new Cadena(lineas[i]);
          token = cad.getToken();
          if (token != null) {
            switch(token) {
              case '#':
                continue;
              case 'mtllib':
                let nombreArchivoMTL = cad.getToken();
                this.lee_datos_archivo_mtl(nombreArchivoMTL);
                break;
              case 'v':
                x = cad.getFloat();
                y = cad.getFloat();
                z = cad.getFloat();
                this.vertices.push(x);
                this.vertices.push(y);
                this.vertices.push(z);
                numVertices++;
                minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
                break;
              case 'g':
              case 'group':
                let nombreGrupo = cad.getToken();
                indiceDeGrupo = this.buscaGrupo(nombreGrupo);
                if (indiceDeGrupo == -1) {
                  let grupo = new Grupo();
                  grupo.setNombre(nombreGrupo);
                  this.grupos.push(grupo);
                  indiceDeGrupo = this.grupos.length - 1;
                }
                hayGrupos = true;
                break;
              case 'usemtl':
                let nombreMaterial = cad.getToken();
                let indiceDeMaterial = this.buscaMaterial(nombreMaterial);
                if (!hayGrupos){
                  indiceDeGrupo = this.buscaMaterialPorGrupo(indiceDeMaterial);
                  if (indiceDeGrupo == -1) {
                    let grupo = new Grupo();
                    grupo.setNombre(nombreMaterial);
                    this.grupos.push(grupo);
                    indiceDeGrupo = this.grupos.length - 1;
                  }
                }
                this.grupos[indiceDeGrupo].setMaterial(indiceDeMaterial);
                break;
              case 'f':
                a = cad.getInt()-1;
                this.indices.push(a);
                b = cad.getInt()-1;
                this.indices.push(b);
                b = cad.getInt()-1;
                this.indices.push(b);

                this.grupos[indiceDeGrupo].adiTriangulo(numTriangulos);
                numTriangulos++;

                let tokenEntero = cad.getInt();
                while (tokenEntero != null) {
                  this.indices.push(a);
                  this.indices.push(b);
                  b = tokenEntero-1;
                  this.indices.push(b);

                  this.grupos[indiceDeGrupo].adiTriangulo(numTriangulos);
                  numTriangulos++;

                  tokenEntero = cad.getInt();
                }
                break;
             }
          }
        }

        // Normalizar coordenadas entre [-1,1]
        let tam_max = 0, escala;
        tam_max = Math.max(tam_max, maxX-minX);
        tam_max = Math.max(tam_max, maxY-minY);
        tam_max = Math.max(tam_max, maxZ-minZ);
        escala = 2.0 / tam_max;

        for (let i = 0; i < numVertices * 3; i += 3) {
          this.vertices[i  ] = escala * (this.vertices[i  ] - minX) - 1.0;
          this.vertices[i+1] = escala * (this.vertices[i+1] - minY) - 1.0;
          this.vertices[i+2] = escala * (this.vertices[i+2] - minZ) - 1.0;
        }
        
        console.log(`Objeto cargado: ${nombreArchivo}, Vértices: ${this.vertices.length/3}, Triángulos: ${numTriangulos}`);
      }

      dibuja(gl, color) {
        let numTriangulos, indiceDeMaterial, k;
        
        for (let i = 0; i < this.grupos.length; i++) {
          numTriangulos = this.grupos[i].getNumTriangulos();
          if (numTriangulos == 0) continue;

          let indAux = new Uint16Array(numTriangulos * 3);
          
          for (let j = 0; j < numTriangulos; j++) {
            k = j * 3;
            let numTrian = this.grupos[i].getTriangulo(j);
            indAux[k    ] = this.indices[numTrian * 3 + 0];
            indAux[k + 1] = this.indices[numTrian * 3 + 1];
            indAux[k + 2] = this.indices[numTrian * 3 + 2];
          }

          let codigoVertices = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          let codigoDeIndices = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indAux), gl.STATIC_DRAW);

          // Si estamos usando colores originales y hay materiales, usarlos
          if (usarColoresOriginales && this.materiales.length > 0) {
            indiceDeMaterial = this.grupos[i].getMaterial();
            if (indiceDeMaterial >= 0 && indiceDeMaterial < this.materiales.length) {
              let colorMaterial = this.materiales[indiceDeMaterial].getDifuso();
              gl.uniform4f(uColor, colorMaterial[0], colorMaterial[1], colorMaterial[2], 1);
            } else {
              // Si no hay material, usar el color por defecto
              gl.uniform4f(uColor, color[0], color[1], color[2], 1);
            }
          } else {
            // Usar el color proporcionado
            gl.uniform4f(uColor, color[0], color[1], color[2], 1);
          }
          
          gl.drawElements(gl.TRIANGLES, numTriangulos * 3, gl.UNSIGNED_SHORT, 0);

          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      }

      leeArchivo(nombreArchivo){
        let byteArray = [];
        let request = new XMLHttpRequest();
        request.onreadystatechange = function () {
          if (request.readyState === 4 && request.status !== 404) {
            byteArray = request.responseText;
          }
        }
        request.open('GET', nombreArchivo, false);
        request.send(null);
        return byteArray;
      }

      lee_datos_archivo_mtl(nombreArchivoMTL) {
        let datos_mtl = this.leeArchivo("Modelos/" + nombreArchivoMTL);
        let lineas = datos_mtl.split('\n');
        let token;
        
        for (let i = 0; i < lineas.length; i++) {
          let cad = new Cadena(lineas[i]);
          token = cad.getToken();
          if (token != null) {
            switch(token){
              case '#':
                continue;
              case 'newmtl':
                let nombreMaterial = cad.getToken();
                let material = new Material();
                material.setNombre(nombreMaterial);
                this.materiales.push(material);
                break;
              case 'Ka':
                let ambiente = new Array(3);
                ambiente[0] = cad.getFloat();
                ambiente[1] = cad.getFloat();
                ambiente[2] = cad.getFloat();
                this.materiales[this.materiales.length-1].setAmbiente(ambiente);
                break;
              case 'Kd':
                let difuso = new Array(3);
                difuso[0] = cad.getFloat();
                difuso[1] = cad.getFloat();
                difuso[2] = cad.getFloat();
                this.materiales[this.materiales.length-1].setDifuso(difuso);
                break;
              case 'Ks':
                let especular = new Array(3);
                especular[0] = cad.getFloat();
                especular[1] = cad.getFloat();
                especular[2] = cad.getFloat();
                this.materiales[this.materiales.length-1].setEspecular(especular);
                break;
              case 'Ns':
                let brillo = cad.getFloat();
                this.materiales[this.materiales.length-1].setBrillo(brillo);
                break;                    
            }
          }
        }
      }
      
      buscaGrupo(nombre) {
        for (let i = 0; i < this.grupos.length; i++)
          if (nombre == this.grupos[i].getNombre())
            return i;
        return -1;
      }

      buscaMaterial(nombre) {
        for (let i = 0; i < this.materiales.length; i++)
          if (nombre == this.materiales[i].getNombre())
            return i;
        return -1;
      }

      buscaMaterialPorGrupo(indice) {
        for (let i = 0; i < this.grupos.length; i++)
          if (indice == this.grupos[i].getMaterial())
            return i;
        return -1;
      }
    }

    /***************************************************************************/
    /* Funciones para crear objetos simples (ejes, mallas)                    */
    /***************************************************************************/
    function crearEjes(gl) {
      const vertices = [
        // Eje X (rojo)
        -10, 0, 0,
        10, 0, 0,
        // Eje Y (verde)
        0, -10, 0,
        0, 10, 0,
        // Eje Z (azul)
        0, 0, -10,
        0, 0, 10
      ];
      
      const colores = [
        1, 0, 0, 1,  // Rojo para eje X
        1, 0, 0, 1,
        0, 1, 0, 1,  // Verde para eje Y
        0, 1, 0, 1,
        0, 0, 1, 1,  // Azul para eje Z
        0, 0, 1, 1
      ];
      
      const indices = [
        0, 1,  // Eje X
        2, 3,  // Eje Y
        4, 5   // Eje Z
      ];
      
      return {
        vertices: vertices,
        colores: colores,
        indices: indices,
        dibujar: function() {
          let codigoVertices = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
          
          let codigoDeIndices = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
          
          // Dibujar cada eje con su color
          for (let i = 0; i < 3; i++) {
            const colorIndex = i * 2;
            gl.uniform4f(uColor, 
              this.colores[colorIndex * 4], 
              this.colores[colorIndex * 4 + 1], 
              this.colores[colorIndex * 4 + 2], 
              this.colores[colorIndex * 4 + 3]
            );
            gl.drawElements(gl.LINES, 2, gl.UNSIGNED_SHORT, i * 2 * 2);
          }
          
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      };
    }

    /***************************************************************************/
    /* Funciones de WebGL y renderizado                                        */
    /***************************************************************************/
    function compilaEnlazaLosShaders() {
      let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeVertice));
      }

      let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeFragmento));
      }

      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice); 
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
         console.error(gl.getProgramInfoLog(programaID));
      }

      gl.useProgram(programaID);
    }

    function dibujar() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
      // Dibujar ejes si está activado
      if (controles.mostrarEjes.checked) {
        identidad(MatrizModelo);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
        ejes.dibujar();
      }
      
      // Dibujar auto
      identidad(MatrizModeloAuto);
      traslacion(MatrizModeloAuto, posicionAuto.x, posicionAuto.y, posicionAuto.z);
      // CORRECCIÓN: Aplicar rotaciones en el orden correcto
      rotacionZ(MatrizModeloAuto, rotacionAuto.z);
      rotacionY(MatrizModeloAuto, rotacionAuto.y);
      rotacionX(MatrizModeloAuto, rotacionAuto.x);
      escalacion(MatrizModeloAuto, escalaAuto, escalaAuto, escalaAuto);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloAuto);
      objetoAuto.dibuja(gl, colorAuto);
      
      // Dibujar gato
      identidad(MatrizModeloGato);
      traslacion(MatrizModeloGato, posicionGato.x, posicionGato.y, posicionGato.z);
      // CORRECCIÓN: Aplicar rotaciones en el orden correcto
      rotacionZ(MatrizModeloGato, rotacionGato.z);
      rotacionY(MatrizModeloGato, rotacionGato.y);
      rotacionX(MatrizModeloGato, rotacionGato.x);
      escalacion(MatrizModeloGato, escalaGato, escalaGato, escalaGato);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloGato);
      objetoGato.dibuja(gl, colorGato);
      
      // Dibujar pingüino
      identidad(MatrizModeloPinguino);
      traslacion(MatrizModeloPinguino, posicionPinguino.x, posicionPinguino.y, posicionPinguino.z);
      // CORRECCIÓN: Aplicar rotaciones en el orden correcto
      rotacionZ(MatrizModeloPinguino, rotacionPinguino.z);
      rotacionY(MatrizModeloPinguino, rotacionPinguino.y);
      rotacionX(MatrizModeloPinguino, rotacionPinguino.x);
      escalacion(MatrizModeloPinguino, escalaPinguino, escalaPinguino, escalaPinguino);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloPinguino);
      objetoPinguino.dibuja(gl, colorPinguino);
      
      // Actualizar animación si está activa
      if (animacionActiva) {
        rotacionAuto.y = (rotacionAuto.y + INC_ROTACION) % 360;
        rotacionGato.y = (rotacionGato.y + INC_ROTACION) % 360;
        rotacionPinguino.y = (rotacionPinguino.y + INC_ROTACION) % 360;
        
        // Actualizar controles si el objeto seleccionado está en animación
        if (objetoSeleccionado === "auto" || objetoSeleccionado === "todos") {
          controles.rotY.value = rotacionAuto.y;
        }
        if (objetoSeleccionado === "gato" || objetoSeleccionado === "todos") {
          controles.rotY.value = rotacionGato.y;
        }
        if (objetoSeleccionado === "pinguino" || objetoSeleccionado === "todos") {
          controles.rotY.value = rotacionPinguino.y;
        }
      }
      
      requestAnimationFrame(dibujar);
    }

    function cargarModelos() {
      document.getElementById("status").textContent = "Cargando modelos...";
      
      // Crear objetos
      objetoAuto = new Objeto(gl, "Modelos/Car.obj");
      objetoGato = new Objeto(gl, "Modelos/gato.obj");
      objetoPinguino = new Objeto(gl, "Modelos/PenguinBaseMesh.obj");
      
      // Crear ejes
      ejes = crearEjes(gl);
      
      document.getElementById("status").textContent = "Listo";
    }

    function main() {
      let canvas = document.getElementById("webglcanvas");
      
      // Configurar el canvas para alta resolución
      const devicePixelRatio = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      
      gl = canvas.getContext("webgl2", {
        antialias: true,  // Habilitar antialiasing
        alpha: false,
        preserveDrawingBuffer: false
      });
      
      if (!gl) {
         document.write("WebGL 2.0 no está disponible en tu navegador");
         return;
      }
      
      // Configurar viewport y compilar shaders
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      compilaEnlazaLosShaders();
      
      // Obtener ubicaciones de uniformes
      uColor = gl.getUniformLocation(programaID, "uColor");
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      
      // Configurar proyección y vista inicial
      configurarProyeccion();
      configurarVista();
      
      // Habilitar depth testing
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(176/255, 196/255, 222/255, 1.0);
      
      // Inicializar controles UI
      inicializarControles();
      
      // Cargar modelos y comenzar renderizado
      cargarModelos();
      dibujar();
    }

    window.onload = main;
  </script>
</body>
</html>