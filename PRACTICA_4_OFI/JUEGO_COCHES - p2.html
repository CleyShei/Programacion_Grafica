<!DOCTYPE html>
<html lang="es">
<head>
    <title>Carrera de Coches - WebGL 2.0 con Texturas y Paisaje</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
    <h2>Carrera de Coches</h2>
    <p>Puntos: <span id="puntos">0</span></p>
    <canvas id="webglcanvas" style="border:none;" width="500" height="500"></canvas>

    <img src="pista.jpeg" id="texturaFondo" hidden /> 
    <img src="jugador.png" id="texturaJugador" hidden />
    <img src="enemigo.png" id="texturaEnemigo" hidden />
    <img src="izquierda.jpg" id="texturaPaisajeIzquierdo" hidden />
    <img src="derecha.jpg" id="texturaPaisajeDerecho" hidden />
    
    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista; 
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura; 
        out vec2 vCoordenadasDeTextura;

        void main() {
            vCoordenadasDeTextura = aCoordenadasDeTextura;
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform vec4 uColor;
        uniform sampler2D uUnidadDeTextura; 
        uniform bool uUsarTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;

        void main() {
            if (uUsarTextura) {
                color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
            } else {
                color = uColor;
            }
        }
    </script>

    <script>
        'use strict';
        
        /* ---------------------------------------------------------------- */
        /* VARIABLES GLOBALES Y UNIFORMES       */ 
        /* ---------------------------------------------------------------- */
        let gl;        
        let programaID;
        let rectanguloVAO;
        
        
        let canvas; 
        
        let uMatrizProyeccion; 
        let uMatrizVista;
        let uMatrizModelo; 
        let uUnidadDeTextura;
        let uColor;
        let uUsarTextura;

        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);

        // Variables de juego
        let codigoTexturaFondo, codigoTexturaJugador, codigoTexturaEnemigo;
        let codigoTexturaPaisajeIzquierdo, codigoTexturaPaisajeDerecho;

        let jugador;
        let enemigos = [];
        let gameOver = false;
        let puntos = 0;

        /* ---------------------------------------------------------------- */
        /* FUNCIONES DE MATRICES*/
        /* ---------------------------------------------------------------- */

        function toRadians(grados) { return grados * Math.PI / 180; };
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }
        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] = 0; r[ 8] = 0; r[12] = -(der + izq)/(der - izq);
          r[1] = 0; r[5] = 2/(arr - abj); r[ 9] = 0; r[13] = -(arr + abj)/(arr - abj);
          r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }
        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        /* ---------------------------------------------------------------- */
        /* COMPILACIÓN Y ENLACE DE SHADERS   */
        /* ---------------------------------------------------------------- */
        function compilaEnlazaLosShaders() {
            let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice);
            if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
                console.error("Shader de Vértice Error:", gl.getShaderInfoLog(shaderDeVertice));
            }

            let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento);
            if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
                console.error("Shader de Fragmento Error:", gl.getShaderInfoLog(shaderDeFragmento));
            }

            programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice);
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);
            if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
                console.error("Enlace de Programa Error:", gl.getProgramInfoLog(programaID));
            }
        }

        /* ---------------------------------------------------------------- */
        /* CLASE RECTANGULOGL */
        /* ---------------------------------------------------------------- */
        class RectanguloGL {
            constructor(gl) {
                let vertices = [0, 0, 1, 0, 1, 1, 0, 1];
                let coord_textura = [0, 0, 1, 0, 1, 1, 0, 1];

                this.rectanguloVAO = gl.createVertexArray();
                gl.bindVertexArray(this.rectanguloVAO);

                let codigoVertices = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                let codigoCoordenadasDeTextura = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, codigoCoordenadasDeTextura);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coord_textura), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            }

            muestra(gl) {
                gl.bindVertexArray(this.rectanguloVAO);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                gl.bindVertexArray(null);
            }
        }
        
        /* ---------------------------------------------------------------- */
        /* MANEJO DE TEXTURAS  */
        /* ---------------------------------------------------------------- */

        function leeLaTextura(gl, ID_del_archivo, codigoDeTextura) {
            gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            let imagen = document.getElementById(ID_del_archivo);
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        /* ---------------------------------------------------------------- */
        /* LÓGICA DEL JUEGO */
        /* ---------------------------------------------------------------- */

        class ObjetoJuego{
          constructor(x,y,w,h,vel){
            this.x=x;this.y=y;this.ancho=w;this.alto=h;this.velocidad=vel;
            this.PADDING = 0.10; 
          }
          
          colisionRR(r){
            const paddingX_A = this.ancho * this.PADDING;
            const paddingY_A = this.alto * this.PADDING;
            const A_izq = this.x + paddingX_A;
            const A_der = this.x + this.ancho - paddingX_A;
            const A_abj = this.y + paddingY_A;
            const A_arr = this.y + this.alto - paddingY_A;

            const paddingX_B = r.ancho * r.PADDING;
            const paddingY_B = r.alto * r.PADDING;
            const B_izq = r.x + paddingX_B;
            const B_der = r.x + r.ancho - paddingX_B;
            const B_abj = r.y + paddingY_B;
            const B_arr = r.y + r.alto - paddingY_B;

            return (A_izq < B_der && A_der > B_izq &&
                    A_abj < B_arr && A_arr > B_abj);
          }
        }

        // Función de dibujo unificada para Color y Textura (Sin cambios)
        function dibujaRect(r, color, codigoTextura = null){
            identidad(MatrizModelo);
            traslacion(MatrizModelo, r.x, r.y, 0);
            escalacion(MatrizModelo, r.ancho, r.alto, 1);
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            
            if (codigoTextura) {
                gl.uniform1i(uUsarTextura, true);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, codigoTextura);
                gl.uniform1i(uUnidadDeTextura, 0); 
            } else {
                gl.uniform1i(uUsarTextura, false);
                gl.uniform4f(uColor, color[0], color[1], color[2], 1);
                gl.bindTexture(gl.TEXTURE_2D, null); 
            }
            
            rectanguloVAO.muestra(gl);
        }

        function dibujaEscenario(){
            let fondo=new ObjetoJuego(-4,-5,8,10,0);
            dibujaRect(fondo, [0.3,0.3,0.3], codigoTexturaFondo);

            let paisajeIzq = new ObjetoJuego(-5,-5,1,10,0);
            dibujaRect(paisajeIzq, [0,0,0], codigoTexturaPaisajeIzquierdo);

            let paisajeDer = new ObjetoJuego(4,-5,1,10,0);
            dibujaRect(paisajeDer, [0,0,0], codigoTexturaPaisajeDerecho);

            for(let i=-5;i<5;i+=2){
              let linea=new ObjetoJuego(-0.1,i,0.2,0.6,0);
              dibujaRect(linea,[0.8,0.8,0.8]);
            }
        }

        function dibuja() {
            if(gameOver){ 
              alert("💥 ¡Chocaste! Game Over\nPuntaje: "+puntos);
              return; 
            }
            gl.clear(gl.COLOR_BUFFER_BIT);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

            dibujaEscenario();

            for(let e of enemigos){
              e.y-=0.05;
              if(e.y<-5){ 
                e.y=5+Math.random()*3; 
                e.x=(Math.random()<0.5)?-2.5:1.5; 
                puntos++; 
                document.getElementById("puntos").textContent=puntos;
              }
              if(jugador.colisionRR(e)) gameOver=true;
              dibujaRect(e, [0,0,0], codigoTexturaEnemigo);
            }

            dibujaRect(jugador, [0,0,0], codigoTexturaJugador);

            requestAnimationFrame(dibuja);
        }

        // control mouse
        function clickMouse(e){
           
            let xCanvas=e.clientX-canvas.getBoundingClientRect().left;
            if(xCanvas<canvas.width/2) jugador.x=-2.5; // carril izquierdo
            else jugador.x=1.5; // carril derecho
        }

        /* ---------------------------------------------------------------- */
        /* FUNCIÓN PRINCIPAL MAIN */
        /* ---------------------------------------------------------------- */
        function main(){
            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
            if (!gl) { alert("WebGL 2.0 no está disponible en tu navegador"); return; }
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            //Se compilan y enlazan los programas Shader
            compilaEnlazaLosShaders();
            gl.useProgram(programaID);

            //Se define la geometría y se almacenan en los buffers
            rectanguloVAO = new RectanguloGL(gl);

            // Se obtiene los ID de las variables de entrada de los shaders
            uColor = gl.getUniformLocation(programaID, "uColor");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uUnidadDeTextura = gl.getUniformLocation(programaID, "uUnidadDeTextura");
            uUsarTextura = gl.getUniformLocation(programaID, "uUsarTextura");
            
            //Se define la proyección
            ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            // Carga de Texturas (Código de juego)
            codigoTexturaFondo = gl.createTexture(); leeLaTextura(gl, "texturaFondo", codigoTexturaFondo);
            codigoTexturaJugador = gl.createTexture(); leeLaTextura(gl, "texturaJugador", codigoTexturaJugador);
            codigoTexturaEnemigo = gl.createTexture(); leeLaTextura(gl, "texturaEnemigo", codigoTexturaEnemigo);
            codigoTexturaPaisajeIzquierdo = gl.createTexture(); leeLaTextura(gl, "texturaPaisajeIzquierdo", codigoTexturaPaisajeIzquierdo);
            codigoTexturaPaisajeDerecho = gl.createTexture(); leeLaTextura(gl, "texturaPaisajeDerecho", codigoTexturaPaisajeDerecho);
            
            // Configuración de juego
            // Se inicializa la variable global 'jugador'
            jugador=new ObjetoJuego(-2.5,-4,2,2.5,0); 
            for(let i=0;i<3;i++){
              enemigos.push(new ObjetoJuego((Math.random()<0.5)?-2.5:1.5,5+i*3,2,2.5,0));
            }

            canvas.addEventListener("click",clickMouse,false);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            //Se renderizan los objetos
            dibuja();
        }
        window.onload=main;
    </script>
</body>
</html>