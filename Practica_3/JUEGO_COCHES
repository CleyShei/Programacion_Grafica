<!DOCTYPE html>
<html lang="es">
<head>
  <title>Carrera de Coches - WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<h2>Carrera de Coches</h2>
<p>Puntos: <span id="puntos">0</span></p>
<canvas id="webglcanvas" style="border:none;" width="500" height="500"></canvas>

<!-- Shaders -->
<script id="vs" type="vertex">
  #version 300 es
  uniform mat4 uMatrizProyeccion;
  uniform mat4 uMatrizModelo;
  layout(location = 0) in vec2 aVertices;
  void main() {
      gl_Position = uMatrizProyeccion * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
  }
</script>

<script id="fs" type="fragment">
  #version 300 es
  precision mediump float;
  uniform vec4 uColor;
  out vec4 color;
  void main() {
      color = uColor;
  }
</script>

<script>

/* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r); // M = M * T
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Rotación sobre Z - glRotatef */
        function rotacionZ(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
          r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
          r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
            r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
            r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }


class Rectangulo{
  constructor(x,y,w,h,vel){
    this.x=x;this.y=y;this.ancho=w;this.alto=h;this.velocidad=vel;
  }
  colisionRR(r){
    return (this.x < r.x + r.ancho && this.x + this.ancho > r.x &&
            this.y < r.y + r.alto && this.y + this.alto > r.y);
  }
}


let canvas,gl;
let rectanguloVAO,uMatrizModelo,uMatrizProyeccion,uColor;
let MatrizProyeccion=new Array(16),MatrizModelo=new Array(16);

let jugador;
let enemigos=[];
let gameOver=false;
let puntos=0;


function dibujaRect(r,color){
  identidad(MatrizModelo);
  traslacion(MatrizModelo,r.x,r.y,0);
  escalacion(MatrizModelo,r.ancho,r.alto,1);
  gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
  gl.uniform4f(uColor,color[0],color[1],color[2],1);
  gl.bindVertexArray(rectanguloVAO);
  gl.drawArrays(gl.TRIANGLE_FAN,0,4);
}

function dibujaEscenario(){
  // Fondo gris (carretera)
  let fondo=new Rectangulo(-5,-5,10,10,0);
  dibujaRect(fondo,[0.3,0.3,0.3]);

  // Laterales verdes
  let izq=new Rectangulo(-5,-5,1,10,0);
  let der=new Rectangulo(4,-5,1,10,0);
  dibujaRect(izq,[0,0.3,0]);
  dibujaRect(der,[0,0.3,0]);

  // Líneas blancas
  for(let i=-5;i<5;i+=2){
    let linea=new Rectangulo(-0.1,i,0.2,0.6,0);
    dibujaRect(linea,[0.8,0.8,0.8]);
  }
}

function dibuja(){
  if(gameOver){ 
    alert("💥 ¡Chocaste! Game Over\nPuntaje: "+puntos);
    return; 
  }
  gl.clear(gl.COLOR_BUFFER_BIT);

  dibujaEscenario();

  // Enemigos
  for(let e of enemigos){
    e.y-=0.05;
    if(e.y<-5){ 
      e.y=5+Math.random()*3; 
      e.x=(Math.random()<0.5)?-2:2; 
      puntos++; 
      document.getElementById("puntos").textContent=puntos;
    }
    if(jugador.colisionRR(e)) gameOver=true;
    dibujaRect(e,[0,0.6,0]);
  }

  // jugador
  dibujaRect(jugador,[0.8,0,0]);

  requestAnimationFrame(dibuja);
}

// control mouse
function clickMouse(e){
  let xCanvas=e.clientX-canvas.getBoundingClientRect().left;
  if(xCanvas<canvas.width/2) jugador.x=-2; // izquierda
  else jugador.x=2; // derecha
}

// -----MAIN 
function main(){
  canvas=document.getElementById("webglcanvas");
  gl=canvas.getContext("webgl2");
  gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

  // Compilación de Shaders
  let vs=gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs,document.getElementById("vs").text.trim());
  gl.compileShader(vs);

  let fs=gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs,document.getElementById("fs").text.trim());
  gl.compileShader(fs);

  let prog=gl.createProgram();
  gl.attachShader(prog,vs);gl.attachShader(prog,fs);
  gl.linkProgram(prog);gl.useProgram(prog);

  // Buffer
  let vertices=[0,0, 1,0, 1,1, 0,1];
  rectanguloVAO=gl.createVertexArray();gl.bindVertexArray(rectanguloVAO);
  let buffer=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  // Uniforms
  uColor=gl.getUniformLocation(prog,"uColor");
  uMatrizModelo=gl.getUniformLocation(prog,"uMatrizModelo");
  uMatrizProyeccion=gl.getUniformLocation(prog,"uMatrizProyeccion");

  ortho(MatrizProyeccion,-5,5,-5,5,-1,1);
  gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);

  // Crea jugador y enemigos 
  jugador=new Rectangulo(-2,-4,1,1.5,0);
  for(let i=0;i<3;i++){
    enemigos.push(new Rectangulo((Math.random()<0.5)?-2:2,5+i*3,1,1.5,0));
  }

  canvas.addEventListener("click",clickMouse,false);

  gl.clearColor(0,0,0,1);
  dibuja();
}
window.onload=main;
</script>
</body>
</html>
