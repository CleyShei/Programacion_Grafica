<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Pop It con Cron√≥metro</title>
  <style>
    body { margin: 0; background: black; }
    canvas { display: block; margin: auto; background: #111; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 20px;
    }
    #hud span { margin-right: 20px; }
    #mensajeFinal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: Arial, sans-serif;
      font-size: 50px;
      font-weight: bold;
      text-align: center;
      color: white;
      display: none;
    }
  </style>
</head>
<body>
  <!-- HUD con el puntaje y el cron√≥metro -->
  <div id="hud">
    <span id="score">Puntos: 0</span>
    <span id="timer">Tiempo: 20</span>
  </div>
  <!-- Mensaje final de GANASTE o PERDISTE -->
  <div id="mensajeFinal"></div>
  <!-- Lienzo WebGL -->
  <canvas id="webglcanvas" width="700" height="600"></canvas>

  <!-- Vertex Shader: controla la posici√≥n y escala del c√≠rculo -->
  <script id="vs" type="x-shader/x-vertex">
    #version 300 es
    in vec2 aVertices;
    uniform vec2 uPos;
    uniform float uEscala;
    void main() {
      gl_Position = vec4(aVertices * uEscala + uPos, 0.0, 1.0);
    }
  </script>

  <!-- Fragment Shader: controla el color del c√≠rculo -->
  <script id="fs" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;
    uniform vec3 uColor;
    out vec4 fragColor;
    void main() {
      fragColor = vec4(uColor, 1.0);
    }
  </script>

  <script>
    const canvas = document.getElementById("webglcanvas");
    const gl = canvas.getContext("webgl2");
    const scoreDiv = document.getElementById("score");
    const timerDiv = document.getElementById("timer");
    const mensajeFinal = document.getElementById("mensajeFinal");

    function identidad(r) {
      r[0]=1;r[4]=0;r[8]=0;r[12]=0;
      r[1]=0;r[5]=1;r[9]=0;r[13]=0;
      r[2]=0;r[6]=0;r[10]=1;r[14]=0;
      r[3]=0;r[7]=0;r[11]=0;r[15]=1;
    }

    function traslacion(m, tx, ty, tz) {
      let r = new Array(16);
      r[0]=1;r[4]=0;r[8]=0;r[12]=tx;
      r[1]=0;r[5]=1;r[9]=0;r[13]=ty;
      r[2]=0;r[6]=0;r[10]=1;r[14]=tz;
      r[3]=0;r[7]=0;r[11]=0;r[15]=1;
      multiplica(m,m,r);
    }

    function escala(m, sx, sy, sz) {
      let r = new Array(16);
      r[0]=sx;r[4]=0;r[8]=0;r[12]=0;
      r[1]=0;r[5]=sy;r[9]=0;r[13]=0;
      r[2]=0;r[6]=0;r[10]=sz;r[14]=0;
      r[3]=0;r[7]=0;r[11]=0;r[15]=1;
      multiplica(m,m,r);
    }

    function multiplica(c,a,b) {
      let r=new Array(16);
      for(let i=0;i<4;i++){
        for(let j=0;j<4;j++){
          let s=0;
          for(let k=0;k<4;k++)
            s+=a[i+k*4]*b[k+j*4];
          r[i+j*4]=s;
        }
      }
      for(let i=0;i<16;i++) c[i]=r[i];
    }

    function ortho(r,izq,der,abj,arr,cerca,lejos) {
      r[0]=2/(der-izq); r[4]=0; r[8]=0; r[12]=-(der+izq)/(der-izq);
      r[1]=0; r[5]=2/(arr-abj); r[9]=0; r[13]=-(arr+abj)/(arr-abj);
      r[2]=0; r[6]=0; r[10]=-2/(lejos-cerca); r[14]=-(lejos+cerca)/(lejos-cerca);
      r[3]=0; r[7]=0; r[11]=0; r[15]=1;
    }

    // Funci√≥n para compilar shaders
    function compilarShader(id, type) {
      const src = document.getElementById(id).textContent.trim();
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error en shader:", gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    // Compilamos y enlazamos shaders
    const vs = compilarShader("vs", gl.VERTEX_SHADER);
    const fs = compilarShader("fs", gl.FRAGMENT_SHADER);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // Obtenemos ubicaciones de variables en los shaders
    const aVertices = gl.getAttribLocation(prog, "aVertices");
    const uPos = gl.getUniformLocation(prog, "uPos");
    const uEscala = gl.getUniformLocation(prog, "uEscala");
    const uColor = gl.getUniformLocation(prog, "uColor");

    // Creamos la figura del c√≠rculo usando tri√°ngulos en abanico
    const numSegmentos = 50;
    const vertices = [0, 0];
    for (let i = 0; i <= numSegmentos; i++) {
      let ang = i * 2 * Math.PI / numSegmentos;
      vertices.push(Math.cos(ang), Math.sin(ang));
    }
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(aVertices, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aVertices);

    // Configuraci√≥n del tablero de c√≠rculos estilo "Pop It"
    const filas = 5;
    const columnas = 6;
    let circulos = [];
    let puntos = 0;
    let tiempo = 20; // segundos del cron√≥metro
    let juegoActivo = true;

    // Colores de cada fila en modo arcoiris
    function colorPorFila(f) {
      const colores = [
        [1, 0, 0],   // rojo
        [1, 0.5, 0], // naranja
        [1, 1, 0],   // amarillo
        [0, 1, 0],   // verde
        [0, 0, 1]    // azul
      ];
      return colores[f % colores.length];
    }

    // Generamos todos los c√≠rculos en filas y columnas
    function crearCirculos() {
      circulos = [];
      for (let f = 0; f < filas; f++) {
        for (let c = 0; c < columnas; c++) {
          circulos.push({
            x: -0.8 + c * 0.3,  // posici√≥n X
            y: 0.7 - f * 0.3,   // posici√≥n Y
            radio: 0.12,
            color: colorPorFila(f),
            activo: true        // activo = no presionado
          });
        }
      }
    }
    crearCirculos();

    // Evento de clic: si clickeamos dentro de un c√≠rculo ‚Üí lo desactivamos
    canvas.addEventListener("click", (e) => {
      if (!juegoActivo) return;
      const rect = canvas.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
      const y = -(((e.clientY - rect.top) / canvas.height) * 2 - 1);

      circulos.forEach(c => {
        if (c.activo) {
          const dx = x - c.x;
          const dy = y - c.y;
          if (Math.sqrt(dx*dx + dy*dy) < c.radio) {
            c.activo = false; 
            puntos++;
            scoreDiv.textContent = "Puntos: " + puntos;

            // Si ya apret√≥ todos los c√≠rculos ‚Üí Gana
            if (puntos === filas * columnas) {
              mostrarResultado(true);
            }
          }
        }
      });
    });

    // Funci√≥n que lleva el cron√≥metro
    function iniciarCronometro() {
      const intervalo = setInterval(() => {
        if (!juegoActivo) return clearInterval(intervalo);
        if (tiempo > 0) {
          tiempo--;
          timerDiv.textContent = "Tiempo: " + tiempo;
        } else {
          juegoActivo = false;
          timerDiv.textContent = "Tiempo: 0 (Fin)";
          clearInterval(intervalo);

          // Al acabarse el tiempo revisamos si gan√≥ o perdi√≥
          if (puntos === filas * columnas) {
            mostrarResultado(true);
          } else {
            mostrarResultado(false);
          }
        }
      }, 1000);
    }
    iniciarCronometro();

    // Mostrar mensaje final en pantalla
    function mostrarResultado(ganaste) {
      juegoActivo = false;
      if (ganaste) {
        mensajeFinal.textContent = "¬°Ganaste üòÄ!";
        mensajeFinal.style.color = "lime";
      } else {
        mensajeFinal.textContent = "¬°Perdiste üò¢!";
        mensajeFinal.style.color = "red";
      }
      mensajeFinal.style.display = "block";
    }

    // Funci√≥n principal de renderizado
    function render() {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      circulos.forEach(c => {
        gl.uniform2f(uPos, c.x, c.y);
        gl.uniform1f(uEscala, c.radio);
        if (c.activo) {
          gl.uniform3fv(uColor, c.color); // color original
        } else {
          gl.uniform3fv(uColor, [0.2, 0.2, 0.2]); // color oscuro si ya fue presionado
        }
        gl.drawArrays(gl.TRIANGLE_FAN, 0, numSegmentos + 2);
      });

      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
