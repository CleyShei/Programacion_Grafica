<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Visualizador 3D con Texturas e Iluminación</title>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; background:#f0f0f0; overflow:hidden; }
    #container { display:flex; height:100vh; }
    #canvas-container { flex:1; position:relative; }
    #webglcanvas { width:100%; height:100%; display:block; }
    #controls { width:320px; background:#2c3e50; color:#fff; padding:15px; overflow-y:auto; box-shadow:-2px 0 5px rgba(0,0,0,.2); }
    .control-group { margin-bottom:20px; border-bottom:1px solid #34495e; padding-bottom:15px; }
    .control-group h3 { margin-top:0; color:#3498db; font-size:16px; }
    .control-row { display:flex; align-items:center; margin-bottom:10px; }
    .control-label { width:140px; font-size:14px; }
    .control-input { flex:1; }
    input[type="range"]{width:100%}
    input[type="color"]{ width:100%; height:30px; border:none; border-radius:3px;}
    button{ background:#3498db; color:white; border:none; padding:8px 12px; border-radius:3px; cursor:pointer; width:100%; margin-top:5px;}
    button:hover{background:#2980b9}
    select{ width:100%; padding:5px; border-radius:3px; border:1px solid #34495e; background:#34495e; color:white;}
    .checkbox-container{ display:flex; align-items:center;}
    .info-text{ font-size:12px; color:#bdc3c7; margin-top:5px;}
    #status { position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.7); color:white; padding:5px 10px; border-radius:3px; font-size:12px; }
    .slider-value { margin-left:10px; font-size:12px; color:#3498db; min-width:30px; }
  </style>
</head>
<body>
  <div id="container">
    <div id="canvas-container">
      <canvas id="webglcanvas"></canvas>
      <div id="status">Cargando modelos...</div>
    </div>
    <div id="controls">
      <div class="control-group">
        <h3>Vista y Navegación</h3>
        <div class="control-row">
          <div class="control-label">Tipo de Vista:</div>
          <div class="control-input">
            <select id="vista">
              <option value="perspectiva">Perspectiva</option>
              <option value="ortogonal">Ortogonal</option>
            </select>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Zoom:</div>
          <div class="control-input">
            <input type="range" id="zoom" min="1" max="20" value="8" step="0.1">
            <span id="zoom-value" class="slider-value">8</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotar Vista X:</div>
          <div class="control-input">
            <input type="range" id="rotarVistaX" min="-180" max="180" value="0">
            <span id="rotarVistaX-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotar Vista Y:</div>
          <div class="control-input">
            <input type="range" id="rotarVistaY" min="-180" max="180" value="0">
            <span id="rotarVistaY-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="info-text">Usa las flechas para mover la vista</div>
      </div>
      
      <div class="control-group">
        <h3>Objeto Seleccionado</h3>
        <div class="control-row">
          <div class="control-label">Objeto:</div>
          <div class="control-input">
            <select id="objetoSeleccionado">
              <option value="todos">Todos los Objetos</option>
              <option value="auto">Auto</option>
              <option value="gato">Gato</option>
              <option value="pinguino">Pingüino</option>
            </select>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Posición X:</div>
          <div class="control-input">
            <input type="range" id="posX" min="-3" max="3" value="0" step="0.1">
            <span id="posX-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Posición Y:</div>
          <div class="control-input">
            <input type="range" id="posY" min="-3" max="3" value="0" step="0.1">
            <span id="posY-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación Y:</div>
          <div class="control-input">
            <input type="range" id="rotX" min="0" max="360" value="0">
            <span id="rotX-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación Z:</div>
          <div class="control-input">
            <input type="range" id="rotY" min="0" max="360" value="0">
            <span id="rotY-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Rotación X:</div>
          <div class="control-input">
            <input type="range" id="rotZ" min="0" max="360" value="0">
            <span id="rotZ-value" class="slider-value">0</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Escala:</div>
          <div class="control-input">
            <input type="range" id="escala" min="0.1" max="3" value="1" step="0.1">
            <span id="escala-value" class="slider-value">1</span>
          </div>
        </div>
        <button id="resetObjeto">Reiniciar Objeto</button>
      </div>
      
      <div class="control-group">
        <h3>Iluminación</h3>
        <div class="control-row">
          <div class="control-label">Brillo:</div>
          <div class="control-input">
            <input type="range" id="brillo" min="1" max="200" value="50">
            <span id="brillo-value" class="slider-value">50</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Luz X:</div>
          <div class="control-input">
            <input type="range" id="luzX" min="-10" max="10" value="3" step="0.1">
            <span id="luzX-value" class="slider-value">3</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Luz Y:</div>
          <div class="control-input">
            <input type="range" id="luzY" min="-10" max="10" value="3" step="0.1">
            <span id="luzY-value" class="slider-value">3</span>
          </div>
        </div>
        <div class="control-row">
          <div class="control-label">Luz Z:</div>
          <div class="control-input">
            <input type="range" id="luzZ" min="-10" max="10" value="-2" step="0.1">
            <span id="luzZ-value" class="slider-value">-2</span>
          </div>
        </div>
        <div class="checkbox-container">
          <input type="checkbox" id="iluminacionActiva" checked>
          <label for="iluminacionActiva">Iluminación Activa</label>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Apariencia</h3>
        <div class="control-row">
          <div class="control-label">Color Auto:</div>
          <div class="control-input"><input type="color" id="colorAuto" value="#ff0000"></div>
        </div>
        <div class="control-row">
          <div class="control-label">Color Gato:</div>
          <div class="control-input"><input type="color" id="colorGato" value="#ff8800"></div>
        </div>
        <div class="control-row">
          <div class="control-label">Color Pingüino:</div>
          <div class="control-input"><input type="color" id="colorPinguino" value="#1a1a1a"></div>
        </div>
        <div class="checkbox-container">
          <input type="checkbox" id="animacion">
          <label for="animacion">Animación Automática</label>
        </div>
        <div class="checkbox-container">
          <input type="checkbox" id="mostrarEjes" checked>
          <label for="mostrarEjes">Mostrar Ejes</label>
        </div>
        <div class="checkbox-container">
          <input type="checkbox" id="usarColoresOriginales" checked>
          <label for="usarColoresOriginales">Usar Textura</label>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Controles Rápidos</h3>
        <button id="vistaFrontal">Vista Frontal</button>
        <button id="vistaLateral">Vista Lateral</button>
        <button id="vistaSuperior">Vista Superior</button>
        <button id="resetTodo">Reiniciar Todo</button>
      </div>
    </div>
  </div>

  <!-- SHADERS CON ILUMINACIÓN -->
  <script id="vs" type="vertex">
    #version 300 es
    precision mediump float;
    
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    uniform mat3 uMatrizNormal;
    
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec2 aTexCoord;
    layout(location = 2) in vec3 aNormales;
    
    out vec2 vTexCoord;
    out vec3 vNormales;
    out vec3 vVertices;
    
    void main() {
      vTexCoord = aTexCoord;
      
      // Transformar vértices a espacio de vista
      vec4 verticeVista = uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
      vVertices = verticeVista.xyz / verticeVista.w;
      
      // Transformar normales a espacio de vista
      vNormales = uMatrizNormal * aNormales;
      
      gl_Position = uMatrizProyeccion * verticeVista;
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    
    in vec2 vTexCoord;
    in vec3 vNormales;
    in vec3 vVertices;
    
    uniform sampler2D uSampler;
    uniform vec4 uColor;
    uniform int uUseTexture;
    uniform int uIluminacionActiva;
    
    uniform vec3 uPosicionLuz;
    uniform vec3 uPosicionVista;
    uniform vec3 u_Ia;
    uniform vec3 u_Id;
    uniform vec3 u_Is;
    uniform vec3 u_ka;
    uniform vec3 u_kd;
    uniform vec3 u_ks;
    uniform float u_brillo;
    
    out vec4 color;
    
    void main() {
      vec4 colorBase;
      
      // Obtener color base (textura o color sólido)
      if (uUseTexture == 1) {
        colorBase = texture(uSampler, vTexCoord);
      } else {
        colorBase = uColor;
      }
      
      // Si la iluminación está desactivada, usar solo color base
      if (uIluminacionActiva == 0) {
        color = colorBase;
        return;
      }
      
      // Vectores para iluminación
      vec3 N = normalize(vNormales);
      vec3 L = normalize(uPosicionLuz - vVertices);
      vec3 V = normalize(uPosicionVista - vVertices);
      vec3 H = normalize(L + V);
      
      // Factores de iluminación
      float NL = max(0.0, dot(N, L));
      float NH = max(0.0, dot(N, H));
      
      // Componentes de iluminación
      vec3 luzAmbiente = u_ka * u_Ia;
      vec3 luzDifusa = u_kd * u_Id * NL;
      vec3 luzEspecular = u_ks * u_Is * pow(NH, u_brillo);
      
      // Modelo de iluminación combinado con textura/color
      vec3 rgb = (luzAmbiente + luzDifusa) * colorBase.rgb + luzEspecular;
      
      // Asegurar que los valores estén en el rango [0, 1]
      rgb = clamp(rgb, 0.0, 1.0);
      
      color = vec4(rgb, colorBase.a);
    }
  </script>

  <script>
  "use strict";

  let programaID, gl;
  let objetoAuto, objetoGato, objetoPinguino;
  let ejes;
  
  // Variables uniformes existentes
  let uColor, uMatrizProyeccion, uMatrizVista, uMatrizModelo, uSampler, uUseTexture;
  
  // Nuevas variables uniformes para iluminación
  let uMatrizNormal, uPosicionVista, uPosicionLuz;
  let u_Ia, u_Id, u_Is, u_ka, u_kd, u_ks, u_brillo, uIluminacionActiva;

  // Matrices
  let MatrizProyeccion = new Array(16);
  let MatrizVista = new Array(16);
  let MatrizModelo = new Array(16);
  let MatrizModeloAuto = new Array(16);
  let MatrizModeloGato = new Array(16);
  let MatrizModeloPinguino = new Array(16);
  let MatrizNormal = new Array(9);

  // Estado de los objetos
  let rotacionAuto = { x:0, y:0, z:0 };
  let rotacionGato = { x:0, y:0, z:0 };
  let rotacionPinguino = { x:0, y:0, z:0 };
  
  let posicionAuto = { x:-2, y:0, z:0 };
  let posicionGato = { x:0, y:0, z:0 };
  let posicionPinguino = { x:2, y:0, z:0 };
  
  let escalaAuto = 1.0, escalaGato = 1.0, escalaPinguino = 1.0;
  
  let colorAuto = [1, 0, 0];
  let colorGato = [1, 0.53, 0];
  let colorPinguino = [0.1, 0.1, 0.1];
  
  let rotacionVistaX = 0, rotacionVistaY = 0, zoom = 8, tipoVista = "perspectiva";
  let animacionActiva = false, INC_ROTACION = 0.5;
  let objetoSeleccionado = "todos", usarColoresOriginales = true;
  
  // Variables de iluminación
  let posicionLuz = [3, 3, -2];
  let posicionVista = [0, 0, 0];
  let brilloMaterial = 50;
  let iluminacionActiva = true;
  
  // Controles
  let controles = {};

  // Funciones matemáticas
  function toRadians(g) { return g * Math.PI / 180; }
  
  function identidad(r) { 
    r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0; 
    r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0; 
    r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0; 
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
  }
  
  function identidad3x3(r) {
    r[0] = 1; r[3] = 0; r[6] = 0;
    r[1] = 0; r[4] = 1; r[7] = 0;
    r[2] = 0; r[5] = 0; r[8] = 1;
  }

  function multiplica(c, a, b) { 
    let r = new Array(16); 
    for(let i = 0; i < 4; i++) { 
      for(let j = 0; j < 4; j++) { 
        let s = 0; 
        for(let k = 0; k < 4; k++) 
          s += a[i + k * 4] * b[k + j * 4]; 
        r[i + j * 4] = s; 
      }
    } 
    for(let i = 0; i < 16; i++) 
      c[i] = r[i];
  }

  function traslacion(matriz, tx, ty, tz) { 
    let r = new Array(16);
    r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
    r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
    r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    multiplica(matriz, matriz, r);
  }

  function escalacion(matriz, sx, sy, sz) { 
    let r = new Array(16);
    r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
    r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
    r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    multiplica(matriz, matriz, r);
  }

  function rotacionX(matriz, theta) { 
    let r = new Array(16);
    let c = Math.cos(toRadians(theta));
    let s = Math.sin(toRadians(theta));
    r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
    r[1] = 0; r[5] = c; r[9] = -s; r[13] = 0;
    r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    multiplica(matriz, matriz, r);
  }

  function rotacionY(matriz, theta) { 
    let r = new Array(16);
    let c = Math.cos(toRadians(theta));
    let s = Math.sin(toRadians(theta));
    r[0] = c; r[4] = 0; r[8] = s; r[12] = 0;
    r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
    r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    multiplica(matriz, matriz, r);
  }

  function rotacionZ(matriz, theta) { 
    let r = new Array(16);
    let c = Math.cos(toRadians(theta));
    let s = Math.sin(toRadians(theta));
    r[0] = c; r[4] = -s; r[8] = 0; r[12] = 0;
    r[1] = s; r[5] = c; r[9] = 0; r[13] = 0;
    r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    multiplica(matriz, matriz, r);
  }

  function ortho(r, izq, der, abj, arr, cerca, lejos) {
    r[0] = 2/(der-izq); r[4] = 0; r[8] = 0; r[12] = -(der+izq)/(der-izq);
    r[1] = 0; r[5] = 2/(arr-abj); r[9] = 0; r[13] = -(arr+abj)/(arr-abj);
    r[2] = 0; r[6] = 0; r[10] = -2/(lejos-cerca); r[14] = -(lejos+cerca)/(lejos-cerca);
    r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
  }

  function perspective(r, fovy, aspecto, cerca, lejos) {
    let ang = fovy * 0.5;
    let f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
    r[0] = f/aspecto; r[4] = 0; r[8] = 0; r[12] = 0;
    r[1] = 0; r[5] = f; r[9] = 0; r[13] = 0;
    r[2] = 0; r[6] = 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2.0*lejos*cerca/(lejos-cerca);
    r[3] = 0; r[7] = 0; r[11] = -1.0; r[15] = 0;
  }

  // Función para transponer matriz
  function transpuesta(r, m) {
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        r[i + j * 4] = m[j + i * 4];
      }
    }
  }

  // Función para invertir matriz (simplificada para matrices ortogonales)
  function invertirMatriz(r, m) {
    // Para matrices de transformación (rotación + traslación) podemos usar esta versión simplificada
    // La inversa de una matriz ortogonal es su transpuesta para la parte de rotación
    // y la traslación es -traslación * rotación^T
    
    // Copiar la matriz de rotación (3x3 superior izquierda)
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        r[i + j * 4] = m[j + i * 4]; // Transponer para invertir rotación
      }
    }
    
    // Invertir la traslación
    let tx = m[12], ty = m[13], tz = m[14];
    r[12] = -(tx * r[0] + ty * r[4] + tz * r[8]);
    r[13] = -(tx * r[1] + ty * r[5] + tz * r[9]);
    r[14] = -(tx * r[2] + ty * r[6] + tz * r[10]);
    
    // Última fila y columna
    r[3] = r[7] = r[11] = 0;
    r[15] = 1;
  }

  // Calcular matriz normal (transpuesta de la inversa de la parte superior 3x3)
  function calcularMatrizNormal(matrizModeloVista, resultado) {
    // Extraer la submatriz 3x3 de rotación
    let m00 = matrizModeloVista[0], m01 = matrizModeloVista[4], m02 = matrizModeloVista[8];
    let m10 = matrizModeloVista[1], m11 = matrizModeloVista[5], m12 = matrizModeloVista[9];
    let m20 = matrizModeloVista[2], m21 = matrizModeloVista[6], m22 = matrizModeloVista[10];
    
    // Calcular determinante
    let det = m00 * (m11 * m22 - m12 * m21) -
              m01 * (m10 * m22 - m12 * m20) +
              m02 * (m10 * m21 - m11 * m20);
    
    // Si el determinante es 0, usar matriz identidad
    if (Math.abs(det) < 1e-8) {
      identidad3x3(resultado);
      return;
    }
    
    // Calcular inversa (simplificada para nuestra aplicación)
    let invDet = 1.0 / det;
    
    resultado[0] = (m11 * m22 - m12 * m21) * invDet;
    resultado[3] = (m02 * m21 - m01 * m22) * invDet;
    resultado[6] = (m01 * m12 - m02 * m11) * invDet;
    
    resultado[1] = (m12 * m20 - m10 * m22) * invDet;
    resultado[4] = (m00 * m22 - m02 * m20) * invDet;
    resultado[7] = (m02 * m10 - m00 * m12) * invDet;
    
    resultado[2] = (m10 * m21 - m11 * m20) * invDet;
    resultado[5] = (m01 * m20 - m00 * m21) * invDet;
    resultado[8] = (m00 * m11 - m01 * m10) * invDet;
  }

  // Inicializar controles
  function inicializarControles() {
    controles.vista = document.getElementById("vista");
    controles.zoom = document.getElementById("zoom");
    controles.rotarVistaX = document.getElementById("rotarVistaX");
    controles.rotarVistaY = document.getElementById("rotarVistaY");
    controles.objetoSeleccionado = document.getElementById("objetoSeleccionado");
    controles.posX = document.getElementById("posX");
    controles.posY = document.getElementById("posY");
    controles.rotX = document.getElementById("rotX");
    controles.rotY = document.getElementById("rotY");
    controles.rotZ = document.getElementById("rotZ");
    controles.escala = document.getElementById("escala");
    controles.colorAuto = document.getElementById("colorAuto");
    controles.colorGato = document.getElementById("colorGato");
    controles.colorPinguino = document.getElementById("colorPinguino");
    controles.animacion = document.getElementById("animacion");
    controles.mostrarEjes = document.getElementById("mostrarEjes");
    controles.usarColoresOriginales = document.getElementById("usarColoresOriginales");
    controles.resetObjeto = document.getElementById("resetObjeto");
    controles.vistaFrontal = document.getElementById("vistaFrontal");
    controles.vistaLateral = document.getElementById("vistaLateral");
    controles.vistaSuperior = document.getElementById("vistaSuperior");
    controles.resetTodo = document.getElementById("resetTodo");
    
    // Nuevos controles de iluminación
    controles.brillo = document.getElementById("brillo");
    controles.luzX = document.getElementById("luzX");
    controles.luzY = document.getElementById("luzY");
    controles.luzZ = document.getElementById("luzZ");
    controles.iluminacionActiva = document.getElementById("iluminacionActiva");
    
    // Event listeners para controles existentes
    controles.vista.addEventListener("change", actualizarVista);
    controles.zoom.addEventListener("input", actualizarZoom);
    controles.rotarVistaX.addEventListener("input", actualizarRotacionVista);
    controles.rotarVistaY.addEventListener("input", actualizarRotacionVista);
    controles.objetoSeleccionado.addEventListener("change", cambiarObjetoSeleccionado);
    controles.posX.addEventListener("input", actualizarPosicion);
    controles.posY.addEventListener("input", actualizarPosicion);
    controles.rotX.addEventListener("input", actualizarRotacion);
    controles.rotY.addEventListener("input", actualizarRotacion);
    controles.rotZ.addEventListener("input", actualizarRotacion);
    controles.escala.addEventListener("input", actualizarEscala);
    controles.colorAuto.addEventListener("input", actualizarColor);
    controles.colorGato.addEventListener("input", actualizarColor);
    controles.colorPinguino.addEventListener("input", actualizarColor);
    controles.animacion.addEventListener("change", toggleAnimacion);
    controles.mostrarEjes.addEventListener("change", dibujar);
    controles.usarColoresOriginales.addEventListener("change", toggleColoresOriginales);
    controles.resetObjeto.addEventListener("click", resetObjeto);
    controles.vistaFrontal.addEventListener("click", () => cambiarVista('frontal'));
    controles.vistaLateral.addEventListener("click", () => cambiarVista('lateral'));
    controles.vistaSuperior.addEventListener("click", () => cambiarVista('superior'));
    controles.resetTodo.addEventListener("click", resetTodo);
    
    // Event listeners para controles de iluminación
    controles.brillo.addEventListener("input", actualizarIluminacion);
    controles.luzX.addEventListener("input", actualizarIluminacion);
    controles.luzY.addEventListener("input", actualizarIluminacion);
    controles.luzZ.addEventListener("input", actualizarIluminacion);
    controles.iluminacionActiva.addEventListener("change", actualizarIluminacion);
    
    // Actualizar valores de sliders
    function actualizarSliderValue(sliderId, valueId) {
      const slider = document.getElementById(sliderId);
      const valueSpan = document.getElementById(valueId);
      if (slider && valueSpan) {
        slider.addEventListener('input', function() {
          valueSpan.textContent = this.value;
        });
        // Establecer valor inicial
        valueSpan.textContent = slider.value;
      }
    }
    
    // Actualizar todos los sliders
    actualizarSliderValue('zoom', 'zoom-value');
    actualizarSliderValue('rotarVistaX', 'rotarVistaX-value');
    actualizarSliderValue('rotarVistaY', 'rotarVistaY-value');
    actualizarSliderValue('posX', 'posX-value');
    actualizarSliderValue('posY', 'posY-value');
    actualizarSliderValue('rotX', 'rotX-value');
    actualizarSliderValue('rotY', 'rotY-value');
    actualizarSliderValue('rotZ', 'rotZ-value');
    actualizarSliderValue('escala', 'escala-value');
    actualizarSliderValue('brillo', 'brillo-value');
    actualizarSliderValue('luzX', 'luzX-value');
    actualizarSliderValue('luzY', 'luzY-value');
    actualizarSliderValue('luzZ', 'luzZ-value');
    
    document.addEventListener("keydown", manejarTeclado);
    actualizarControlesDesdeEstado();
  }

  function actualizarControlesDesdeEstado() {
    controles.zoom.value = zoom;
    controles.rotarVistaX.value = rotacionVistaX;
    controles.rotarVistaY.value = rotacionVistaY;
    controles.vista.value = tipoVista;
    
    // Controles de iluminación
    controles.brillo.value = brilloMaterial;
    controles.luzX.value = posicionLuz[0];
    controles.luzY.value = posicionLuz[1];
    controles.luzZ.value = posicionLuz[2];
    controles.iluminacionActiva.checked = iluminacionActiva;
    
    actualizarControlesObjeto();
  }

  function actualizarControlesObjeto() {
    let posX, posY, rotX, rotY, rotZ, escala;
    switch(objetoSeleccionado){
      case "auto": 
        posX = posicionAuto.x; 
        posY = posicionAuto.y; 
        rotX = rotacionAuto.x; 
        rotY = rotacionAuto.y; 
        rotZ = rotacionAuto.z; 
        escala = escalaAuto; 
        break;
      case "gato": 
        posX = posicionGato.x; 
        posY = posicionGato.y; 
        rotX = rotacionGato.x; 
        rotY = rotacionGato.y; 
        rotZ = rotacionGato.z; 
        escala = escalaGato; 
        break;
      case "pinguino": 
        posX = posicionPinguino.x; 
        posY = posicionPinguino.y; 
        rotX = rotacionPinguino.x; 
        rotY = rotacionPinguino.y; 
        rotZ = rotacionPinguino.z; 
        escala = escalaPinguino; 
        break;
      default: 
        posX = 0; posY = 0; rotX = 0; rotY = 0; rotZ = 0; escala = 1;
    }
    controles.posX.value = posX; 
    controles.posY.value = posY; 
    controles.rotX.value = rotX; 
    controles.rotY.value = rotY; 
    controles.rotZ.value = rotZ; 
    controles.escala.value = escala;
  }

  // Funciones de manejo de UI
  function actualizarVista() { 
    tipoVista = controles.vista.value; 
    configurarProyeccion(); 
    dibujar(); 
  }
  
  function actualizarZoom() { 
    zoom = parseFloat(controles.zoom.value); 
    configurarProyeccion(); 
    dibujar(); 
  }
  
  function actualizarRotacionVista() { 
    rotacionVistaX = parseFloat(controles.rotarVistaX.value); 
    rotacionVistaY = parseFloat(controles.rotarVistaY.value); 
    configurarVista(); 
    dibujar(); 
  }
  
  function cambiarObjetoSeleccionado() { 
    objetoSeleccionado = controles.objetoSeleccionado.value; 
    actualizarControlesObjeto(); 
  }
  
  function actualizarPosicion() { 
    const x = parseFloat(controles.posX.value), y = parseFloat(controles.posY.value); 
    switch(objetoSeleccionado) { 
      case "auto": 
        posicionAuto.x = x; 
        posicionAuto.y = y; 
        break; 
      case "gato": 
        posicionGato.x = x; 
        posicionGato.y = y; 
        break; 
      case "pinguino": 
        posicionPinguino.x = x; 
        posicionPinguino.y = y; 
        break; 
      case "todos": 
        posicionAuto.x = x; 
        posicionAuto.y = y; 
        posicionGato.x = x; 
        posicionGato.y = y; 
        posicionPinguino.x = x; 
        posicionPinguino.y = y; 
        break;
    } 
    dibujar();
  }
  
  function actualizarRotacion() { 
    const x = parseFloat(controles.rotX.value), y = parseFloat(controles.rotY.value), z = parseFloat(controles.rotZ.value); 
    switch(objetoSeleccionado) { 
      case "auto": 
        rotacionAuto.x = x; 
        rotacionAuto.y = y; 
        rotacionAuto.z = z; 
        break; 
      case "gato": 
        rotacionGato.x = x; 
        rotacionGato.y = y; 
        rotacionGato.z = z; 
        break; 
      case "pinguino": 
        rotacionPinguino.x = x; 
        rotacionPinguino.y = y; 
        rotacionPinguino.z = z; 
        break; 
      case "todos": 
        rotacionAuto.x = x; rotacionAuto.y = y; rotacionAuto.z = z; 
        rotacionGato.x = x; rotacionGato.y = y; rotacionGato.z = z; 
        rotacionPinguino.x = x; rotacionPinguino.y = y; rotacionPinguino.z = z; 
        break;
    } 
    dibujar();
  }
  
  function actualizarEscala() { 
    const s = parseFloat(controles.escala.value); 
    switch(objetoSeleccionado) { 
      case "auto": 
        escalaAuto = s; 
        break; 
      case "gato": 
        escalaGato = s; 
        break; 
      case "pinguino": 
        escalaPinguino = s; 
        break; 
      case "todos": 
        escalaAuto = s; 
        escalaGato = s; 
        escalaPinguino = s; 
        break;
    } 
    dibujar();
  }
  
  function actualizarColor() { 
    function hexToRgb(hex) { 
      const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); 
      return r ? [parseInt(r[1], 16)/255, parseInt(r[2], 16)/255, parseInt(r[3], 16)/255] : [0,0,0];
    } 
    colorAuto = hexToRgb(controles.colorAuto.value); 
    colorGato = hexToRgb(controles.colorGato.value); 
    colorPinguino = hexToRgb(controles.colorPinguino.value); 
    dibujar();
  }
  
  function toggleAnimacion() { 
    animacionActiva = controles.animacion.checked; 
  }
  
  function toggleColoresOriginales() { 
    usarColoresOriginales = controles.usarColoresOriginales.checked; 
    dibujar();
  }
  
  function actualizarIluminacion() {
    brilloMaterial = parseFloat(controles.brillo.value);
    posicionLuz[0] = parseFloat(controles.luzX.value);
    posicionLuz[1] = parseFloat(controles.luzY.value);
    posicionLuz[2] = parseFloat(controles.luzZ.value);
    iluminacionActiva = controles.iluminacionActiva.checked;
    dibujar();
  }
  
  function resetObjeto() { 
    switch(objetoSeleccionado) { 
      case "auto": 
        rotacionAuto = { x:0, y:0, z:0 }; 
        posicionAuto = { x:-2, y:0, z:0 }; 
        escalaAuto = 1.0; 
        break; 
      case "gato": 
        rotacionGato = { x:0, y:0, z:0 }; 
        posicionGato = { x:0, y:0, z:0 }; 
        escalaGato = 1.0; 
        break; 
      case "pinguino": 
        rotacionPinguino = { x:0, y:0, z:0 }; 
        posicionPinguino = { x:2, y:0, z:0 }; 
        escalaPinguino = 1.0; 
        break; 
      case "todos": 
        rotacionAuto = { x:0, y:0, z:0 }; 
        posicionAuto = { x:-2, y:0, z:0 }; 
        escalaAuto = 1.0; 
        rotacionGato = { x:0, y:0, z:0 }; 
        posicionGato = { x:0, y:0, z:0 }; 
        escalaGato = 1.0; 
        rotacionPinguino = { x:0, y:0, z:0 }; 
        posicionPinguino = { x:2, y:0, z:0 }; 
        escalaPinguino = 1.0; 
        break;
    } 
    actualizarControlesObjeto(); 
    dibujar();
  }
  
  function cambiarVista(tipo) { 
    switch(tipo) { 
      case 'frontal': 
        rotacionVistaX = 0; 
        rotacionVistaY = 0; 
        break; 
      case 'lateral': 
        rotacionVistaX = 0; 
        rotacionVistaY = 90; 
        break; 
      case 'superior': 
        rotacionVistaX = 90; 
        rotacionVistaY = 0; 
        break;
    } 
    controles.rotarVistaX.value = rotacionVistaX; 
    controles.rotarVistaY.value = rotacionVistaY; 
    configurarVista(); 
    dibujar();
  }
  
  function resetTodo() { 
    zoom = 8; 
    rotacionVistaX = 0; 
    rotacionVistaY = 0; 
    tipoVista = "perspectiva"; 
    
    rotacionAuto = { x:0, y:0, z:0 }; 
    posicionAuto = { x:-2, y:0, z:0 }; 
    escalaAuto = 1.0; 
    
    rotacionGato = { x:0, y:0, z:0 }; 
    posicionGato = { x:0, y:0, z:0 }; 
    escalaGato = 1.0; 
    
    rotacionPinguino = { x:0, y:0, z:0 }; 
    posicionPinguino = { x:2, y:0, z:0 }; 
    escalaPinguino = 1.0; 
    
    colorAuto = [1, 0, 0]; 
    colorGato = [1, 0.53, 0]; 
    colorPinguino = [0.1, 0.1, 0.1]; 
    
    // Reset iluminación
    brilloMaterial = 50;
    posicionLuz = [3, 3, -2];
    iluminacionActiva = true;
    
    actualizarControlesDesdeEstado(); 
    controles.colorAuto.value = "#ff0000"; 
    controles.colorGato.value = "#ff8800"; 
    controles.colorPinguino.value = "#1a1a1a"; 
    dibujar();
  }
  
  function manejarTeclado(event) { 
    const step = 5, zoomStep = 0.5; 
    switch(event.key) { 
      case "ArrowUp": 
        rotacionVistaX = (rotacionVistaX - step) % 360; 
        break; 
      case "ArrowDown": 
        rotacionVistaX = (rotacionVistaX + step) % 360; 
        break; 
      case "ArrowLeft": 
        rotacionVistaY = (rotacionVistaY - step) % 360; 
        break; 
      case "ArrowRight": 
        rotacionVistaY = (rotacionVistaY + step) % 360; 
        break; 
      case "PageUp": 
        zoom = Math.min(20, zoom + zoomStep); 
        break; 
      case "PageDown": 
        zoom = Math.max(1, zoom - zoomStep); 
        break; 
      default: 
        return;
    } 
    controles.rotarVistaX.value = rotacionVistaX; 
    controles.rotarVistaY.value = rotacionVistaY; 
    controles.zoom.value = zoom; 
    configurarProyeccion(); 
    configurarVista(); 
    dibujar(); 
    event.preventDefault();
  }

  /***************************************************************************/
  /* OBJ & MTL loader con normales                                           */
  /***************************************************************************/
  class Grupo {
    constructor() { 
      this.nombre = "si_falta"; 
      this.triangulos = []; 
      this.material = -1; 
    }
    setNombre(n) { this.nombre = n; }
    getNombre() { return this.nombre; }
    adiTriangulo(t) { this.triangulos.push(t); }
    getTriangulo(i) { return this.triangulos[i]; }
    getNumTriangulos() { return this.triangulos.length; }
    setMaterial(m) { this.material = m; }
    getMaterial() { return this.material; }
  }

  class Material {
    constructor() { 
      this.nombre = "si_falta"; 
      this.ambiente = [0.2, 0.2, 0.2]; 
      this.difuso = [0.8, 0.8, 0.8]; 
      this.especular = [0, 0, 0]; 
      this.brillo = 0; 
      this.mapKd = null; 
      this._glTexture = null; 
    }
    setNombre(n) { this.nombre = n; }
    getNombre() { return this.nombre; }
    setAmbiente(a) { this.ambiente = a; }
    getAmbiente() { return this.ambiente; }
    setDifuso(d) { this.difuso = d; }
    getDifuso() { return this.difuso; }
    setEspecular(s) { this.especular = s; }
    getEspecular() { return this.especular; }
    setBrillo(b) { this.brillo = b; }
    getBrillo() { return this.brillo; }
  }

  class Cadena {
    constructor(c) { 
      this.cadena = c; 
      this.indice = 0; 
    }
    esDelimitador(c) { 
      return (c == ' ' || c == '\t' || c == '(' || c == ')' || c == '"' || c == "'"); 
    }
    saltaDelimitadores() { 
      let n = this.cadena.length; 
      while(this.indice < n && this.esDelimitador(this.cadena.charAt(this.indice))) 
        this.indice++; 
    }
    obtLongPalabra(inicio) { 
      let i = inicio; 
      while(i < this.cadena.length && !this.esDelimitador(this.cadena.charAt(i))) 
        i++; 
      return i - inicio; 
    }
    getToken() { 
      this.saltaDelimitadores(); 
      let n = this.obtLongPalabra(this.indice); 
      if(n === 0) return null; 
      let sub = this.cadena.substr(this.indice, n); 
      this.indice += (n + 1); 
      return sub.trim(); 
    }
    getInt() { 
      let t = this.getToken(); 
      return t ? parseInt(t, 10) : null; 
    }
    getFloat() { 
      let t = this.getToken(); 
      return t ? parseFloat(t) : null; 
    }
  }

  class Objeto {
    constructor(gl, nombreArchivo, colorPorDefecto) {
      this.vertices = []; 
      this.uvs = []; 
      this.normales = []; 
      this.grupos = []; 
      this.materiales = []; 
      this.color = colorPorDefecto || [1, 1, 1];
      
      this.posArray = []; 
      this.uvArray = []; 
      this.normalArray = []; 
      this.indexArrays = []; 
      this.groupMaterials = [];
      
      this.cargarObjeto(gl, nombreArchivo);
      this._createGLBuffers(gl);
    }

    leeArchivo(nombreArchivo) {
      let request = new XMLHttpRequest();
      request.open('GET', nombreArchivo, false);
      request.send(null);
      if (request.status === 404) return "";
      return request.responseText;
    }

    lee_datos_archivo_mtl(nombreArchivoMTL) {
      let datos_mtl = this.leeArchivo("Modelos/" + nombreArchivoMTL);
      if (!datos_mtl) return;
      
      let lineas = datos_mtl.split('\n');
      let token;
      
      for (let i = 0; i < lineas.length; i++) {
        let cad = new Cadena(lineas[i]);
        token = cad.getToken();
        if (token == null) continue;
        
        switch(token) {
          case '#': continue;
          case 'newmtl':
            let nombreMaterial = cad.getToken();
            let material = new Material();
            material.setNombre(nombreMaterial);
            this.materiales.push(material);
            break;
          case 'Ka':
            let ambiente = [cad.getFloat(), cad.getFloat(), cad.getFloat()];
            this.materiales[this.materiales.length - 1].setAmbiente(ambiente);
            break;
          case 'Kd':
            let dif = [cad.getFloat(), cad.getFloat(), cad.getFloat()];
            this.materiales[this.materiales.length - 1].setDifuso(dif);
            break;
          case 'Ks':
            let spec = [cad.getFloat(), cad.getFloat(), cad.getFloat()];
            this.materiales[this.materiales.length - 1].setEspecular(spec);
            break;
          case 'Ns':
            let brillo = cad.getFloat();
            this.materiales[this.materiales.length - 1].setBrillo(brillo);
            break;
          case 'map_Kd':
            let map = cad.getToken();
            if (map) this.materiales[this.materiales.length - 1].mapKd = map.trim();
            break;
        }
      }
    }

    cargarObjeto(gl, nombreArchivo) {
      let datos_obj = this.leeArchivo(nombreArchivo);
      if (!datos_obj) { 
        console.warn("OBJ vacío:", nombreArchivo); 
        return; 
      }
      
      let lineas = datos_obj.split('\n');
      let minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE;
      let minY = Number.MAX_VALUE, maxY = Number.MIN_VALUE;
      let minZ = Number.MAX_VALUE, maxZ = Number.MIN_VALUE;
      
      let numVertices = 0;
      let numTriangulos = 0;
      let indiceDeGrupo = -1;
      let hayGrupos = false;
      
      let positions = [];
      let texcoords = [];
      let normals = [];
      
      this.grupos = [];
      this.materiales = [];

      for (let i = 0; i < lineas.length; i++) {
        let cad = new Cadena(lineas[i]);
        let token = cad.getToken();
        if (token == null) continue;
        
        switch(token) {
          case '#': continue;
          case 'mtllib':
            let nombreMTL = cad.getToken();
            if (nombreMTL) this.lee_datos_archivo_mtl(nombreMTL);
            break;
          case 'v':
            let x = cad.getFloat(), y = cad.getFloat(), z = cad.getFloat();
            positions.push(x); positions.push(y); positions.push(z);
            numVertices++;
            
            minX = Math.min(minX, x); maxX = Math.max(maxX, x);
            minY = Math.min(minY, y); maxY = Math.max(maxY, y);
            minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
            break;
          case 'vt':
            let u = cad.getFloat(), v = cad.getFloat();
            texcoords.push(u); texcoords.push(v);
            break;
          case 'vn':
            let nx = cad.getFloat(), ny = cad.getFloat(), nz = cad.getFloat();
            normals.push(nx); normals.push(ny); normals.push(nz);
            break;
          case 'g':
          case 'group':
            let nombreGrupo = cad.getToken();
            indiceDeGrupo = this.buscaGrupoPorNombre(nombreGrupo);
            if (indiceDeGrupo == -1) { 
              let g = new Grupo(); 
              g.setNombre(nombreGrupo); 
              this.grupos.push(g); 
              indiceDeGrupo = this.grupos.length - 1; 
            }
            hayGrupos = true;
            break;
          case 'usemtl':
            let nombreMaterial = cad.getToken();
            let indiceMaterial = this.buscaMaterial(nombreMaterial);
            if (!hayGrupos) {
              indiceDeGrupo = this.buscaMaterialPorGrupo(indiceMaterial);
              if (indiceDeGrupo == -1) { 
                let g = new Grupo(); 
                g.setNombre(nombreMaterial); 
                this.grupos.push(g); 
                indiceDeGrupo = this.grupos.length - 1; 
              }
            }
            this.grupos[indiceDeGrupo].setMaterial(indiceMaterial);
            break;
          case 'f':
            if (indiceDeGrupo == -1) { 
              let g = new Grupo(); 
              g.setNombre("default"); 
              this.grupos.push(g); 
              indiceDeGrupo = this.grupos.length - 1; 
            }
            
            let faceVerts = [];
            let tkn = cad.getToken();
            while (tkn != null) { 
              faceVerts.push(tkn); 
              tkn = cad.getToken(); 
            }
            
            let aToken = faceVerts[0];
            for (let fi = 1; fi < faceVerts.length - 1; fi++) {
              let bToken = faceVerts[fi];
              let cToken = faceVerts[fi + 1];
              this.grupos[indiceDeGrupo].adiTriangulo([aToken, bToken, cToken]);
              numTriangulos++;
            }
            break;
        }
      }

      // Normalizar el modelo para que quepa en un volumen de 2x2x2
      let tam_max = Math.max(maxX - minX, Math.max(maxY - minY, maxZ - minZ));
      let escala = tam_max === 0 ? 1 : 2.0 / tam_max;
      
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] = escala * (positions[i] - minX) - 1.0;
        positions[i + 1] = escala * (positions[i + 1] - minY) - 1.0;
        positions[i + 2] = escala * (positions[i + 2] - minZ) - 1.0;
      }

      let vertexMap = {};
      let nextIndex = 0;
      
      this.posArray = [];
      this.uvArray = [];
      this.normalArray = [];
      this.indexArrays = [];
      this.groupMaterials = [];

      for (let gi = 0; gi < this.grupos.length; gi++) {
        let grupo = this.grupos[gi];
        let triCount = grupo.getNumTriangulos();
        let indicesList = [];
        
        for (let t = 0; t < triCount; t++) {
          let triTokens = grupo.getTriangulo(t);
          
          for (let k = 0; k < 3; k++) {
            let tokenStr = triTokens[k].trim();
            let parts = tokenStr.split('/');
            
            let vi = parseInt(parts[0], 10);
            let vti = parts.length > 1 && parts[1] !== "" ? parseInt(parts[1], 10) : null;
            let vni = parts.length > 2 && parts[2] !== "" ? parseInt(parts[2], 10) : null;
            
            let key = vi + "/" + (vti ? vti : "") + "/" + (vni ? vni : "");
            
            if (vertexMap[key] === undefined) {
              // Posición
              let px = positions[(vi - 1) * 3];
              let py = positions[(vi - 1) * 3 + 1];
              let pz = positions[(vi - 1) * 3 + 2];
              this.posArray.push(px, py, pz);
              
              // Coordenadas de textura
              if (vti !== null && texcoords.length > 0) {
                let tu = texcoords[(vti - 1) * 2];
                let tv = texcoords[(vti - 1) * 2 + 1];
                this.uvArray.push(tu, tv);
              } else {
                this.uvArray.push(0, 0);
              }
              
              // Normales
              if (vni !== null && normals.length > 0) {
                let nx = normals[(vni - 1) * 3];
                let ny = normals[(vni - 1) * 3 + 1];
                let nz = normals[(vni - 1) * 3 + 2];
                this.normalArray.push(nx, ny, nz);
              } else {
                // Si no hay normales, usar una normal por defecto
                this.normalArray.push(0, 1, 0);
              }
              
              vertexMap[key] = nextIndex++;
            }
            indicesList.push(vertexMap[key]);
          }
        }
        
        this.indexArrays.push(new Uint16Array(indicesList));
        this.groupMaterials.push(grupo.getMaterial());
      }

      // Si no hay normales cargadas, calcular normales aproximadas
      if (normals.length === 0) {
        this.calcularNormales();
      }
      
      console.log(`OBJ procesado: ${nombreArchivo} -> vértices únicos: ${this.posArray.length/3}, grupos: ${this.indexArrays.length}`);
    }

    // Calcular normales aproximadas si no están en el archivo
    calcularNormales() {
      // Reiniciar el array de normales
      this.normalArray = new Array(this.posArray.length).fill(0);
      
      // Calcular normales por triángulo y acumular por vértice
      for (let gi = 0; gi < this.indexArrays.length; gi++) {
        let indices = this.indexArrays[gi];
        
        for (let i = 0; i < indices.length; i += 3) {
          let i1 = indices[i];
          let i2 = indices[i + 1];
          let i3 = indices[i + 2];
          
          // Obtener vértices
          let v1 = [this.posArray[i1 * 3], this.posArray[i1 * 3 + 1], this.posArray[i1 * 3 + 2]];
          let v2 = [this.posArray[i2 * 3], this.posArray[i2 * 3 + 1], this.posArray[i2 * 3 + 2]];
          let v3 = [this.posArray[i3 * 3], this.posArray[i3 * 3 + 1], this.posArray[i3 * 3 + 2]];
          
          // Calcular vectores del triángulo
          let u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          let v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          
          // Producto cruz para obtener normal
          let normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          
          // Normalizar la normal del triángulo
          let length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
          
          // Acumular normal para cada vértice
          for (let j = 0; j < 3; j++) {
            let idx = indices[i + j];
            this.normalArray[idx * 3] += normal[0];
            this.normalArray[idx * 3 + 1] += normal[1];
            this.normalArray[idx * 3 + 2] += normal[2];
          }
        }
      }
      
      // Normalizar todas las normales acumuladas
      for (let i = 0; i < this.normalArray.length; i += 3) {
        let length = Math.sqrt(
          this.normalArray[i] * this.normalArray[i] + 
          this.normalArray[i + 1] * this.normalArray[i + 1] + 
          this.normalArray[i + 2] * this.normalArray[i + 2]
        );
        
        if (length > 0) {
          this.normalArray[i] /= length;
          this.normalArray[i + 1] /= length;
          this.normalArray[i + 2] /= length;
        } else {
          // Si la normal es cero, usar una normal por defecto
          this.normalArray[i] = 0;
          this.normalArray[i + 1] = 1;
          this.normalArray[i + 2] = 0;
        }
      }
    }

    buscaGrupoPorNombre(nombre) { 
      for(let i = 0; i < this.grupos.length; i++) 
        if(this.grupos[i].getNombre() === nombre) 
          return i; 
      return -1; 
    }
    
    buscaMaterial(nombre) { 
      for(let i = 0; i < this.materiales.length; i++) 
        if(this.materiales[i].getNombre() === nombre) 
          return i; 
      return -1; 
    }
    
    buscaMaterialPorGrupo(indice) { 
      for(let i = 0; i < this.grupos.length; i++) 
        if(indice == this.grupos[i].getMaterial()) 
          return i; 
      return -1; 
    }

    _createGLBuffers(gl) {
      // Buffer para posiciones
      this._posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.posArray), gl.STATIC_DRAW);

      // Buffer para coordenadas de textura
      this._uvBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.uvArray), gl.STATIC_DRAW);

      // Buffer para normales
      this._normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.normalArray), gl.STATIC_DRAW);

      // Buffers de índices por grupo
      this._indexBuffers = [];
      for (let i = 0; i < this.indexArrays.length; i++) {
        let ib = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexArrays[i], gl.STATIC_DRAW);
        this._indexBuffers.push(ib);
      }
      
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    _ensureMaterialTextureLoaded(gl, material) {
      if (!material) return null;
      if (material.mapKd == null) return null;
      if (material._glTexture) return material._glTexture;

      let tex = gl.createTexture();
      material._glTexture = tex;

      let img = new Image();
      img.crossOrigin = "";
      img.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        
        function isPowerOf2(v) { return (v & (v - 1)) === 0; }
        if (isPowerOf2(img.width) && isPowerOf2(img.height)) {
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
      };
      
      img.onerror = function() { 
        console.warn("No se pudo cargar textura:", material.mapKd); 
        material._glTexture = null; 
      };
      
      img.src = "Modelos/" + material.mapKd;
      return material._glTexture;
    }

    dibuja(gl, color) {
      // Configurar atributos de posición
      gl.bindBuffer(gl.ARRAY_BUFFER, this._posBuffer);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      // Configurar atributos de textura
      gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

      // Configurar atributos de normales
      gl.bindBuffer(gl.ARRAY_BUFFER, this._normalBuffer);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

      for (let gi = 0; gi < this.indexArrays.length; gi++) {
        let numIndices = this.indexArrays[gi].length;
        let materialIndex = this.groupMaterials[gi];
        let useTexture = 0;
        let texture = null;
        
        if (usarColoresOriginales && materialIndex >= 0 && materialIndex < this.materiales.length) {
          let mat = this.materiales[materialIndex];
          if (mat && mat.mapKd) {
            texture = this._ensureMaterialTextureLoaded(gl, mat);
            if (texture) useTexture = 1;
          } else {
            let dif = mat ? mat.getDifuso() : color;
            gl.uniform4f(uColor, dif[0], dif[1], dif[2], 1);
            useTexture = 0;
          }
        } else {
          gl.uniform4f(uColor, color[0], color[1], color[2], 1);
          useTexture = 0;
        }

        if (useTexture == 1 && texture) {
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(uSampler, 0);
          gl.uniform1i(uUseTexture, 1);
        } else {
          gl.uniform1i(uUseTexture, 0);
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffers[gi]);
        gl.drawElements(gl.TRIANGLES, numIndices, gl.UNSIGNED_SHORT, 0);
      }

      // Deshabilitar atributos
      gl.disableVertexAttribArray(0);
      gl.disableVertexAttribArray(1);
      gl.disableVertexAttribArray(2);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
  }

  function crearEjes(gl) {
    const vertices = [-10, 0, 0, 10, 0, 0, 0, -10, 0, 0, 10, 0, 0, 0, -10, 0, 0, 10];
    const colores = [1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1];
    const indices = [0, 1, 2, 3, 4, 5];
    
    return {
      vertices: vertices, 
      colores: colores, 
      indices: indices,
      dibujar: function() {
        // No usamos normales para los ejes
        identidad3x3(MatrizNormal);
        gl.uniformMatrix3fv(uMatrizNormal, false, MatrizNormal);
        
        let codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        let codigoDeIndices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);

        for (let i = 0; i < 3; i++) {
          const colorIndex = i * 2;
          gl.uniform4f(uColor, this.colores[colorIndex * 4], this.colores[colorIndex * 4 + 1], 
                      this.colores[colorIndex * 4 + 2], this.colores[colorIndex * 4 + 3]);
          gl.drawElements(gl.LINES, 2, gl.UNSIGNED_SHORT, i * 2 * 2);
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.disableVertexAttribArray(0);
      }
    };
  }

  function compilaEnlazaLosShaders() {
    let vsSrc = document.getElementById("vs").text.trim();
    let fsSrc = document.getElementById("fs").text.trim();
    
    let vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSrc);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
      console.error("VS:", gl.getShaderInfoLog(vs));
    
    let fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSrc);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
      console.error("FS:", gl.getShaderInfoLog(fs));
    
    programaID = gl.createProgram();
    gl.attachShader(programaID, vs);
    gl.attachShader(programaID, fs);
    gl.linkProgram(programaID);
    
    if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) 
      console.error("Program:", gl.getProgramInfoLog(programaID));
    
    gl.useProgram(programaID);
    
    // Obtener ubicaciones de variables uniformes
    uColor = gl.getUniformLocation(programaID, "uColor");
    uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
    uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
    uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
    uSampler = gl.getUniformLocation(programaID, "uSampler");
    uUseTexture = gl.getUniformLocation(programaID, "uUseTexture");
    
    // Nuevas variables para iluminación
    uMatrizNormal = gl.getUniformLocation(programaID, "uMatrizNormal");
    uPosicionVista = gl.getUniformLocation(programaID, "uPosicionVista");
    uPosicionLuz = gl.getUniformLocation(programaID, "uPosicionLuz");
    u_Ia = gl.getUniformLocation(programaID, "u_Ia");
    u_Id = gl.getUniformLocation(programaID, "u_Id");
    u_Is = gl.getUniformLocation(programaID, "u_Is");
    u_ka = gl.getUniformLocation(programaID, "u_ka");
    u_kd = gl.getUniformLocation(programaID, "u_kd");
    u_ks = gl.getUniformLocation(programaID, "u_ks");
    u_brillo = gl.getUniformLocation(programaID, "u_brillo");
    uIluminacionActiva = gl.getUniformLocation(programaID, "uIluminacionActiva");
  }

  function configurarProyeccion() {
    const aspecto = gl.canvas.width / gl.canvas.height;
    if (tipoVista === "perspectiva") {
      perspective(MatrizProyeccion, 45, aspecto, 0.1, 100);
    } else {
      ortho(MatrizProyeccion, -zoom * aspecto, zoom * aspecto, -zoom, zoom, -100, 100);
    }
    gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
  }

  function configurarVista() {
    identidad(MatrizVista);
    rotacionY(MatrizVista, rotacionVistaY);
    rotacionX(MatrizVista, rotacionVistaX);
    traslacion(MatrizVista, 0, 0, -zoom);
    gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
  }

  function configurarIluminacion() {
    // Configurar parámetros de iluminación
    gl.uniform3f(u_Ia, 0.2, 0.2, 0.2);    // Intensidad ambiente
    gl.uniform3f(u_Id, 1.0, 1.0, 1.0);    // Intensidad difusa
    gl.uniform3f(u_Is, 1.0, 1.0, 1.0);    // Intensidad especular
    
    // Coeficientes del material (pueden ajustarse por objeto)
    gl.uniform3f(u_ka, 0.8, 0.8, 0.8);    // Coeficiente ambiente
    gl.uniform3f(u_kd, 0.8, 0.8, 0.8);    // Coeficiente difuso
    gl.uniform3f(u_ks, 0.5, 0.5, 0.5);    // Coeficiente especular
    gl.uniform1f(u_brillo, brilloMaterial); // Brillo
    
    // Posición de la vista (en coordenadas de vista)
    gl.uniform3fv(uPosicionVista, posicionVista);
    
    // Posición de la luz (en coordenadas de vista)
    gl.uniform3fv(uPosicionLuz, posicionLuz);
    
    // Estado de la iluminación
    gl.uniform1i(uIluminacionActiva, iluminacionActiva ? 1 : 0);
  }

  function dibujar() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    // Configurar iluminación
    configurarIluminacion();
    
    // Dibujar ejes si está activado
    if (controles.mostrarEjes.checked) {
      identidad(MatrizModelo);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
      ejes.dibujar();
    }

    // Calcular matriz del modelo para el auto
    identidad(MatrizModeloAuto);
    traslacion(MatrizModeloAuto, posicionAuto.x, posicionAuto.y, posicionAuto.z);
    rotacionZ(MatrizModeloAuto, rotacionAuto.z);
    rotacionY(MatrizModeloAuto, rotacionAuto.y);
    rotacionX(MatrizModeloAuto, rotacionAuto.x);
    escalacion(MatrizModeloAuto, escalaAuto, escalaAuto, escalaAuto);
    
    // Calcular matriz normal para el auto
    calcularMatrizNormal(MatrizModeloAuto, MatrizNormal);
    gl.uniformMatrix3fv(uMatrizNormal, false, MatrizNormal);
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloAuto);
    
    // Dibujar auto
    objetoAuto.dibuja(gl, colorAuto);

    // Calcular matriz del modelo para el gato
    identidad(MatrizModeloGato);
    traslacion(MatrizModeloGato, posicionGato.x, posicionGato.y, posicionGato.z);
    rotacionZ(MatrizModeloGato, rotacionGato.z);
    rotacionY(MatrizModeloGato, rotacionGato.y);
    rotacionX(MatrizModeloGato, rotacionGato.x);
    escalacion(MatrizModeloGato, escalaGato, escalaGato, escalaGato);
    
    // Calcular matriz normal para el gato
    calcularMatrizNormal(MatrizModeloGato, MatrizNormal);
    gl.uniformMatrix3fv(uMatrizNormal, false, MatrizNormal);
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloGato);
    
    // Dibujar gato
    objetoGato.dibuja(gl, colorGato);

    // Calcular matriz del modelo para el pingüino
    identidad(MatrizModeloPinguino);
    traslacion(MatrizModeloPinguino, posicionPinguino.x, posicionPinguino.y, posicionPinguino.z);
    rotacionZ(MatrizModeloPinguino, rotacionPinguino.z);
    rotacionY(MatrizModeloPinguino, rotacionPinguino.y);
    rotacionX(MatrizModeloPinguino, rotacionPinguino.x);
    escalacion(MatrizModeloPinguino, escalaPinguino, escalaPinguino, escalaPinguino);
    
    // Calcular matriz normal para el pingüino
    calcularMatrizNormal(MatrizModeloPinguino, MatrizNormal);
    gl.uniformMatrix3fv(uMatrizNormal, false, MatrizNormal);
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModeloPinguino);
    
    // Dibujar pingüino
    objetoPinguino.dibuja(gl, colorPinguino);

    // Animación automática
    if (animacionActiva) {
      rotacionAuto.y = (rotacionAuto.y + INC_ROTACION) % 360;
      rotacionGato.y = (rotacionGato.y + INC_ROTACION) % 360;
      rotacionPinguino.y = (rotacionPinguino.y + INC_ROTACION) % 360;
      
      if (objetoSeleccionado === "todos" || objetoSeleccionado === "gato") {
        controles.rotY.value = rotacionGato.y;
        document.getElementById('rotY-value').textContent = Math.round(rotacionGato.y);
      }
    }

    requestAnimationFrame(dibujar);
  }

  function cargarModelos() {
    document.getElementById("status").textContent = "Cargando modelos...";
    
    // Crear objetos con sus colores por defecto
    objetoAuto = new Objeto(gl, "Modelos/Car.obj", [1, 0, 0]);
    objetoGato = new Objeto(gl, "Modelos/gato.obj", [1, 0.53, 0]);
    objetoPinguino = new Objeto(gl, "Modelos/PenguinBaseMesh.obj", [0.1, 0.1, 0.1]);

    // Forzar texturas para gato y pingüino si no vienen en el MTL
    if (objetoGato.materiales.length === 0) {
      let m = new Material();
      m.setNombre("forcedGato");
      m.mapKd = "texgato.jpg";
      objetoGato.materiales.push(m);
      if (objetoGato.groupMaterials.length > 0) objetoGato.groupMaterials[0] = 0;
    } else {
      for (let i = 0; i < objetoGato.materiales.length; i++) {
        if (!objetoGato.materiales[i].mapKd) objetoGato.materiales[i].mapKd = "texgato.jpg";
      }
    }

    if (objetoPinguino.materiales.length === 0) {
      let m2 = new Material();
      m2.setNombre("forcedPinguino");
      m2.mapKd = "texpingu.jpg";
      objetoPinguino.materiales.push(m2);
      if (objetoPinguino.groupMaterials.length > 0) objetoPinguino.groupMaterials[0] = 0;
    } else {
      for (let i = 0; i < objetoPinguino.materiales.length; i++) {
        if (!objetoPinguino.materiales[i].mapKd) objetoPinguino.materiales[i].mapKd = "texpingu.jpg";
      }
    }

    ejes = crearEjes(gl);
    document.getElementById("status").textContent = "Listo";
  }

  function main() {
    let canvas = document.getElementById("webglcanvas");
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * devicePixelRatio;
    canvas.height = canvas.clientHeight * devicePixelRatio;

    gl = canvas.getContext("webgl2", { antialias: true, alpha: false });
    if (!gl) { 
      document.write("WebGL 2.0 no está disponible en tu navegador"); 
      return; 
    }
    
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    compilaEnlazaLosShaders();

    configurarProyeccion();
    configurarVista();

    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(176/255, 196/255, 222/255, 1.0);

    inicializarControles();
    cargarModelos();
    dibujar();
  }

  window.onload = main;
  </script>
</body>
</html>