<!DOCTYPE HTML>
<html>
<head>
    <title>Textura 2D en WebGL 2.0 - Animación de Sprites</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
    <canvas id="webglcanvas" style="border: none;" width="900" height="500"></canvas>
    
    
    <img src="trineo.png" id="trineo" hidden />
    <img src="nina.png" id="nina" hidden />
    <img src="nino.png" id="nino" hidden />
    <img src="muñeco.png" id="muneco" hidden />
    <img src="arbol.png" id="arbol" hidden />
    <img src="fondonav.jpeg" id="fondo" hidden /> <!-- Imagen de fondo añadida -->
    
    <script id="vs" type="vertex">
        #version 300 es
        precision mediump float;
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        uniform mat4 uMatrizTextura;
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec2 aCoordenadasDeTextura;
        out vec2 vCoordenadasDeTextura;
        void main() {
            // Se utiliza uMatrizTextura para seleccionar el frame de la animación
            vCoordenadasDeTextura = (uMatrizTextura * vec4(aCoordenadasDeTextura, 0.0, 1.0)).xy; 
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D uUnidadDeTextura;
        in vec2 vCoordenadasDeTextura;
        out vec4 color;
        void main() {
            color = texture(uUnidadDeTextura, vCoordenadasDeTextura); 
        }
    </script>
 
    <script>
        "use strict";

        /***************************************************************************/
        /* Transformaciones mediante matrices                                        */
        /***************************************************************************/

        /* Convierte de grados a radianes */
        function toRadians(grados) {
          return grados * Math.PI / 180;
        };

        /* Matriz Identidad */
        function identidad(r) {
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = sy; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Rotación sobre X - glRotatef */
        function rotacionX(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = c; r[ 9] = -s; r[13] = 0;
          r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
          multiplica(matriz, matriz, r); 
        }

        /* Rotación sobre Y - glRotatef */
        function rotacionY(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] = c; r[4] = 0; r[ 8] = s; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }
 
        /* Rotación sobre Z - glRotatef */
        function rotacionZ(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] = c; r[4] = -s; r[ 8] = 0; r[12] = 0;
          r[1] = s; r[5] = c; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] = 0; r[ 8] = 0; r[12] = -(der + izq)/(der - izq);
          r[1] = 0; r[5] = 2/(arr - abj); r[ 9] = 0; r[13] = -(arr + abj)/(arr - abj);
          r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        /* Variables globales */
        let gl;
        let programaID;

        /* Variables Uniformes */
        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;
        let uUnidadDeTextura;
        let uMatrizTextura;

        /* Matrices */
        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);
        let MatrizTextura = new Array(16);

        let tiempo_real;
        let inicio = Date.now(); // Tiempo Inicial
        let fin, duracion;
        const PERIODO_MOVIMIENTO = 0.1; // Para control de animación de sprites
        let tiempoMovimiento = PERIODO_MOVIMIENTO;
        
        let objetos = []; // Array para almacenar todos los sprites/objetos
        let t0 = Date.now(); // Para cálculo de deltaTime (dt) para movimiento

        /***************************************************************************/
        /* Función para crear un Objeto Animado (Sprite)                           */
        /***************************************************************************/
        function crearObjeto(imagenID, numSprites, posX, posY, ancho, alto, velocidadX=0, animar=true, esFondo=false) {
            // Geometría del cuadrilátero centrado en (0, 0)
            let vertices;
            
            if (esFondo) {
                // Para el fondo, cubrir toda el área visible
                vertices = [
                    -ancho/2, -alto/2, // 0
                     ancho/2, -alto/2, // 1
                     ancho/2,  alto/2, // 2
                    -ancho/2,  alto/2, // 3
                ];
            } else {
                vertices = [
                    -ancho/2, -alto/2, // 0
                     ancho/2, -alto/2, // 1
                     ancho/2,  alto/2, // 2
                    -ancho/2,  alto/2, // 3
                ];
            }

            // Coordenadas de textura para el primer sprite (1/numSprites de ancho)
            let coords;
            if (esFondo) {
                // Para el fondo, usar toda la textura
                coords = [
                    0, 0, 
                    1, 0, 
                    1, 1, 
                    0, 1
                ];
            } else {
                coords = [
                    0, 0, 
                    1/numSprites, 0, 
                    1/numSprites, 1, 
                    0, 1
                ];
            }
            
            // Creación de VAO
            let vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            // Buffer de Vértices (location = 0)
            let vBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            // Buffer de Coordenadas de Textura (location = 1)
            let tBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            // Creación de Textura
            let textura = gl.createTexture();
            let img = document.getElementById(imagenID);
            gl.bindTexture(gl.TEXTURE_2D, textura);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);

            // Retorna el objeto sprite con sus propiedades de animación y posición
            return {
                vao: vao,
                textura: textura,
                posX: posX,
                posY: posY,
                numSprites: numSprites,
                velocidadX: velocidadX,
                dt: 0, // Desplazamiento de textura para animación, en fracciones de ancho de sprite (0, 1/N, 2/N, ...)
                animar: animar,
                ancho: ancho,
                alto: alto,
                esFondo: esFondo || false
            };
        }


        function dibuja() {
          gl.clear(gl.COLOR_BUFFER_BIT);

          // Cálculo del tiempo transcurrido desde el último frame
          fin = Date.now(); // Tiempo Final
          duracion = fin - inicio;
          inicio = fin;
          tiempo_real = duracion / 1000.0;
          tiempoMovimiento = tiempoMovimiento - tiempo_real;
          
          // Itera sobre todos los objetos y los dibuja
          for (let i = 0; i < objetos.length; i++) {
              let o = objetos[i];

              // 1. Transformación de Modelo (Posición)
              identidad(MatrizModelo);
              traslacion(MatrizModelo, o.posX, o.posY, 0);
              gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

              // 2. Transformación de Textura (Animación de Sprite)
              identidad(MatrizTextura);
              if (!o.esFondo) {
                  // Solo aplicar animación de sprites si no es el fondo
                  traslacion(MatrizTextura, o.dt, 0, 0); 
              }
              gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

              // 3. Dibujado
              gl.activeTexture(gl.TEXTURE0);
              gl.uniform1i(uUnidadDeTextura, 0);
              gl.bindTexture(gl.TEXTURE_2D, o.textura);
              
              gl.bindVertexArray(o.vao);
              gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
              gl.bindVertexArray(null);

              // 4. Actualización de Posición (Movimiento) - solo para objetos que no son fondo
              if (!o.esFondo) {
                  o.posX += o.velocidadX;
                  
                  // Lógica de límites de movimiento (simulando los límites del segundo código)
                  if (i === 1) { // Trineo (ahora índice 1 porque el fondo es índice 0)
                      if (o.posX > 8) o.posX = -8;
                  } else if (i === 2) { // Niña (índice 2)
                      if (o.posX > -4) o.posX = -4; // Limita movimiento hacia la derecha
                  } else if (i === 3) { // Niño (índice 3)
                      if (o.posX < -1) o.posX = -1; // Limita movimiento hacia la izquierda
                  }

                  // 5. Actualización de Animación de Sprite
                  if (o.animar) {
                    if (tiempoMovimiento < 0.001) { 
                      // El tiempo de animación ha expirado, avanzar al siguiente sprite
                      o.dt += 1/o.numSprites; 
                      // Si 'dt' es igual o mayor a 1 - (1/N) (el inicio del último sprite), resetear a 0.
                      if (o.dt >= (o.numSprites - 1) / o.numSprites + (0.5 / o.numSprites)) { // Pequeña tolerancia para el reset
                        o.dt = 0;
                      }
                    }
                  }
              }
          }

          // Reset del contador de tiempo para animación de sprites
          if (tiempoMovimiento < 0.001) {
            tiempoMovimiento = PERIODO_MOVIMIENTO;
          }

          requestAnimationFrame(dibuja);
        }        

        function main() {
          /***************************************************************************/
          /* Paso 1: Se prepara el lienzo y se obtiene el contexto del WebGL.        */
          /***************************************************************************/
          let canvas = document.getElementById("webglcanvas");

          gl = canvas.getContext("webgl2");
          if (!gl) {
             document.write("WebGL 2.0 no está disponible en tu navegador");
             return;
          }

          /* Se define la ventana de despliegue */
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

          /***************************************************************************/
          /* Paso 2: Se crean, compilan y enlazan los programas Shader               */
          /***************************************************************************/

          /* Se compila el shader de vertice */
          let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
          gl.compileShader(shaderDeVertice);

          /* Se compila el shader de fragmento */
          let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
          gl.compileShader(shaderDeFragmento);

          /* Se enlaza ambos shader */
          programaID = gl.createProgram();
          gl.attachShader(programaID, shaderDeVertice); 
          gl.attachShader(programaID, shaderDeFragmento);
          gl.linkProgram(programaID);

          /* Se instala el programa de shaders para utilizarlo */
          gl.useProgram(programaID);

          // Obtiene los ID de las variables de entrada de los shaders
          uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
          uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
          uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
          uUnidadDeTextura = gl.getUniformLocation(programaID, "uUnidadDeTextura");
          uMatrizTextura = gl.getUniformLocation(programaID, "uMatrizTextura");

          /***************************************************************************/
          /* Paso 3: Se define la geometría y se almacenan en los buffers de memoria.
                     (Se reemplaza la creación de un solo rectángulo estático por 
                      la creación de múltiples objetos animados)                    */
          /***************************************************************************/

          // Crear objetos usando la nueva función que encapsula la geometría y textura.
          // formato: crearObjeto(idImagen, numSprites, posX, posY, ancho, alto, velocidadX, animar, esFondo)
          
          // FONDO - se añade primero para que se dibuje detrás de todo
          objetos.push(crearObjeto("fondo", 1, 0, 0, 16, 10, 0, false, true)); // Fondo estático que cubre toda el área
          
          // Resto de objetos
          objetos.push(crearObjeto("trineo", 6, -8, 3, 6, 2, 0.05, true));   // Trineo: se mueve y anima
          objetos.push(crearObjeto("nina", 6, -7, -2.2, 1.5, 1.8, 0.03, true));    // Niña: se mueve y anima, con límite de X
          objetos.push(crearObjeto("nino", 6, 3.5, -2.3, 1.5, 1.8, -0.03, true));   // Niño: se mueve y anima, con límite de X
          objetos.push(crearObjeto("muneco", 8, -2.5, -2, 2.5, 4, 0, true)); // Muñeco: estático, pero anima
          objetos.push(crearObjeto("arbol", 4, 6, -2, 3, 6, 0, true));    // Árbol: estático, sin animación
          
          /***************************************************************************/
          /* Paso 4: Se renderiza                                                    */
          /***************************************************************************/

          // Matriz de Proyección (se usa el rango más amplio del segundo código para la escena)
          ortho(MatrizProyeccion, -8, 8, -5, 5, -5, 5);
          gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

          // Matriz de Vista (Identidad)
          identidad(MatrizVista);
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista); 
          
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          dibuja();
        }

        /* Llama a main una vez que la página web se haya cargado. */
        window.onload = main;

    </script>
</body>
</html>